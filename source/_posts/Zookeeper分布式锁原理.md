---
title: Zookeeper分布式锁原理
tags: ["Zookeeper", "分布式锁"]
categories: ["Zookeeper"]
---
# Zookeeper分布式锁简单实现
Zookeeper分布式锁的原理很简单，核心就是依托Zookeeper节点唯一性来展开实现的。
![节点唯一性.png](节点唯一性.png)
<!-- more -->
具体来说：假如有10个线程同时创建节点`/lock`（前提是该节点不存在），肯定只有1个线程（T1）能创建成功，其余的9个线程(T2 ~ T10)创建失败（失败并不灰心，它们要监听`/lock`节点的删除事件，以便于后续的尝试）。我们就说线程T1获得了锁，获得了执行后续操作的权利。当线程T1执行完后续操作之后，它就会将`/lock`节点删除，于此同时线程T2 ~ T10得到通知，便一股脑的都去请求Zookeeper服务端，尝试获取锁（也就是创建节点`/lock`）。一样的，这次还是只有一个线程能成功获取到锁，执行完后续操作之后再将锁释放，如此周而复始，实现并发请求的串行化。该原理流程图如下：
![简单实现.png](简单实现.png)
> 基于以上原理的Zookeeper分布式锁简单实现其实存在一些弊端，比如：非公平锁和羊群效应
## 非公平锁
经过以上分析我们可以发现一个问题：那就是每次在争抢锁的时候，大家获得锁的概率是随机的，并没有一个先来后到的机制，也就是所谓的不公平。比如：线程T1首先获得了锁，然后线程T2、T3......T9、T10依次来请求获取锁。但是当线程T1释放锁之后，并不是由线程T2直接接棒，而是大家同时争抢，谁抢到了算谁的。假如此刻线程T10抢到了，是不是对其余线程来说就很不公平。
## 羊群效应
我们想一个问题：每次当一个线程将锁释放之后发生了什么事情呢？答案：其余线程得到通知，然后一股脑的都向Zookeeper服务端发送创建节点请求，但是最终只有一个线程创建成功。我们思考一下，这会带来一个什么问题呢？这样，我们假设有10000并发，第一次争抢锁时会有10000个请求打到Zookeeper服务端，第二次会有9999，第三次会有9998......当最终这10000的并发全部执行完，Zookeeper服务端处理了多少请求呢？等差数列：（10000 + 1） * 10000 / 2 = 50005000，而且其中只有10000个请求是有效的，这无形之中给Zookeeper服务端带来了巨大的压力，也浪费了服务器的资源。
> 羊群效应：一群羊在羊圈外边吃草，突然来了一只狼。羊们害怕极了，都抢着往羊圈里跑。但是羊圈的入口只有一个，大家都挤到了一起，谁都不让谁。就这样，羊入圈的效率极其低下，白白牺牲了好多羊。
# Zookeeper分布式锁进阶实现
Zookeeper的进阶实现巧妙地规避了简单实现的两个问题：非公平和羊群效应。其实现原理大致分为如下几步：
1. 首先判断父节点`/lock`是否存在，如果不存在，则创建（容器）父节点
2. 然后在父节点下创建（临时序号）子节点`/x-000000n`
3. 判断自己是不是父节点下的最小子结点
 3.1 如果是，则获取锁
 3.2 如果不是，则监听前一个节点
4. 获得锁的节点完成业务处理，释放锁，即删除节点
5. 前一个节点得到通知，重复第3步的判断
6. 某客户端由于异常原因导致断开连接，其所对应的子结点自动删除，其后一个节点得到通知，重复第3步的判断
7. 所有子结点均删除，（容器）父节点自动删除

该原理的流程图如下：
![进阶实现.png](进阶实现.png)
该过程对应的Zookeeper节点结构如下：
![节点结构.png](节点结构.png)
# Curator实现分布式锁源码分析
## 锁的实例化
![锁的实例化.png](锁的实例化.png)
实例化完成之后的锁如下：
![锁实例.png](锁实例.png)
## 获取锁
![获取锁.png](获取锁.png)
## 释放锁
![释放锁.png](释放锁.png)

