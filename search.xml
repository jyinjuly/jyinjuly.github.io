<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS安装Docker</title>
    <url>/2022/10/16/CentOS%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h1 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h1><p>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><h2 id="安装前置依赖"><a href="#安装前置依赖" class="headerlink" title="安装前置依赖"></a>安装前置依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
<h2 id="设置-Docker-仓库"><a href="#设置-Docker-仓库" class="headerlink" title="设置 Docker 仓库"></a>设置 Docker 仓库</h2><h3 id="官方源"><a href="#官方源" class="headerlink" title="官方源"></a>官方源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="阿里云源"><a href="#阿里云源" class="headerlink" title="阿里云源"></a>阿里云源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="清华大学源"><a href="#清华大学源" class="headerlink" title="清华大学源"></a>清华大学源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h2 id="执行-Docker-安装"><a href="#执行-Docker-安装" class="headerlink" title="执行 Docker 安装"></a>执行 Docker 安装</h2><h3 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>
<h3 id="指定版本"><a href="#指定版本" class="headerlink" title="指定版本"></a>指定版本</h3><p>要安装特定版本的 Docker，请在存储库中列出可用版本，然后选择并安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/16/CentOS%E5%AE%89%E8%A3%85Docker/Docker%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9.png" alt="Docker版本选择.png"><br>通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>
<h1 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h1 id="验证启动"><a href="#验证启动" class="headerlink" title="验证启动"></a>验证启动</h1><p>通过运行 hello-world 镜像来验证是否启动成功（首次运行可能需要先拉取镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/16/CentOS%E5%AE%89%E8%A3%85Docker/Docker%E5%90%AF%E5%8A%A8%E9%AA%8C%E8%AF%81.png" alt="Docker启动验证.png"></p>
<h1 id="关闭-Docker"><a href="#关闭-Docker" class="headerlink" title="关闭 Docker"></a>关闭 Docker</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/16/CentOS%E5%AE%89%E8%A3%85Docker/Docker%E8%87%AA%E5%8A%A8%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6.png" alt="Docker自动唤醒机制.png"></p>
<h1 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h1><p>删除安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker-ce</span><br></pre></td></tr></table></figure>
<p>删除镜像、容器、配置文件等内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装MySQL</title>
    <url>/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/</url>
    <content><![CDATA[<h1 id="查看可用版本"><a href="#查看可用版本" class="headerlink" title="查看可用版本"></a>查看可用版本</h1><p>访问 MySQL 镜像库地址：<a href="https://hub.docker.com/_/mysql?tab=tags">https://hub.docker.com/_/mysql?tab=tags</a></p>
<span id="more"></span>

<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/%E6%9F%A5%E8%AF%A2%E5%8F%AF%E7%94%A8%E9%95%9C%E5%83%8F.png" alt="查询可用镜像.png"></p>
<h1 id="拉取MySQL镜像"><a href="#拉取MySQL镜像" class="headerlink" title="拉取MySQL镜像"></a>拉取MySQL镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull mysql:8.0.31</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/%E6%8B%89%E5%8F%96MySQL%E9%95%9C%E5%83%8F.png" alt="拉取MySQL镜像.png"></p>
<h1 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" alt="查看本地镜像.png"></p>
<h1 id="运行MySQL容器"><a href="#运行MySQL容器" class="headerlink" title="运行MySQL容器"></a>运行MySQL容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0.31</span><br></pre></td></tr></table></figure>
<ul>
<li>-p 3306:3306：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 <code>宿主机ip:3306</code> 访问到 MySQL 的服务</li>
<li>MYSQL_ROOT_PASSWORD&#x3D;123456：设置MySQL服务root用户的密码</li>
</ul>
<h1 id="验证启动成功"><a href="#验证启动成功" class="headerlink" title="验证启动成功"></a>验证启动成功</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8.png" alt="验证启动.png"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Redis</title>
    <url>/2022/12/27/Docker%E5%AE%89%E8%A3%85Redis/</url>
    <content><![CDATA[<h1 id="查看可用版本"><a href="#查看可用版本" class="headerlink" title="查看可用版本"></a>查看可用版本</h1><p>访问 Redis 镜像库地址：<a href="https://hub.docker.com/_/redis?tab=tags">https://hub.docker.com/_/redis?tab=tags</a></p>
<span id="more"></span>

<p><img src="/2022/12/27/Docker%E5%AE%89%E8%A3%85Redis/%E6%9F%A5%E8%AF%A2Redis%E9%95%9C%E5%83%8F.png" alt="查询Redis镜像.png"></p>
<h1 id="拉取Redis镜像"><a href="#拉取Redis镜像" class="headerlink" title="拉取Redis镜像"></a>拉取Redis镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull redis:5.0.14</span><br></pre></td></tr></table></figure>

<h1 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>

<h1 id="运行MySQL容器"><a href="#运行MySQL容器" class="headerlink" title="运行MySQL容器"></a>运行MySQL容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name redis5 -p 6379:6379 redis:5.0.14</span><br></pre></td></tr></table></figure>

<h1 id="验证启动成功"><a href="#验证启动成功" class="headerlink" title="验证启动成功"></a>验证启动成功</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Zookeeper</title>
    <url>/2022/10/23/Docker%E5%AE%89%E8%A3%85Zookeeper/</url>
    <content><![CDATA[<h1 id="查看可用版本"><a href="#查看可用版本" class="headerlink" title="查看可用版本"></a>查看可用版本</h1><p>访问 Zookeeper 镜像库地址：<a href="https://hub.docker.com/_/zookeeper/tags">https://hub.docker.com/_/zookeeper/tags</a></p>
<span id="more"></span>

<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85Zookeeper/%E6%9F%A5%E8%AF%A2%E5%8F%AF%E7%94%A8%E9%95%9C%E5%83%8F.png" alt="查询可用镜像.png"></p>
<h1 id="拉取Zookeeper镜像"><a href="#拉取Zookeeper镜像" class="headerlink" title="拉取Zookeeper镜像"></a>拉取Zookeeper镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull zookeeper:3.5.8</span><br></pre></td></tr></table></figure>

<h1 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85Zookeeper/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" alt="查看本地镜像.png"></p>
<h1 id="运行Zookeeper容器"><a href="#运行Zookeeper容器" class="headerlink" title="运行Zookeeper容器"></a>运行Zookeeper容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name zookeeper -p 2181:2181 zookeeper:3.5.8</span><br></pre></td></tr></table></figure>
<ul>
<li>-p 2181:2181：映射容器服务的 2181 端口到宿主机的 2181 端口，外部主机可以直接通过 <code>宿主机ip:2181</code> 访问到 Zookeeper 的服务</li>
</ul>
<h1 id="验证启动成功"><a href="#验证启动成功" class="headerlink" title="验证启动成功"></a>验证启动成功</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85Zookeeper/%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8.png" alt="验证启动.png"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器使用</title>
    <url>/2022/10/23/Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull mysql:8.0.31</span><br></pre></td></tr></table></figure>

<h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.31</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="查询运行容器"><a href="#查询运行容器" class="headerlink" title="查询运行容器"></a>查询运行容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/%E6%9F%A5%E8%AF%A2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8.png" alt="查询运行容器.png"></p>
<ul>
<li>CONTAINER ID: 容器id</li>
<li>IMAGE: 镜像</li>
<li>NAMES: 容器名称</li>
</ul>
<h1 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stop e60de6d38a35</span><br></pre></td></tr></table></figure>

<h1 id="查询所有容器"><a href="#查询所有容器" class="headerlink" title="查询所有容器"></a>查询所有容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8.png" alt="查询所有容器.png"></p>
<h1 id="启动停止容器"><a href="#启动停止容器" class="headerlink" title="启动停止容器"></a>启动停止容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker start e60de6d38a35 </span><br></pre></td></tr></table></figure>

<h1 id="重启运行容器"><a href="#重启运行容器" class="headerlink" title="重启运行容器"></a>重启运行容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker restart e60de6d38a35 </span><br></pre></td></tr></table></figure>

<h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it e60de6d38a35 /bin/bash</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用exec进入容器，如果从这个容器退出，容器不会停止；也可以使用<code>docker attach e60de6d38a35</code>进入容器，但是如果从这个容器退出，会导致容器的停止。因此推荐使用exec。</p>
</blockquote>
<h1 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span> -f e60de6d38a35</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像使用</title>
    <url>/2022/10/23/Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" alt="查看本地镜像.png"></p>
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小<span id="more"></span></li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:15.10 /bin/bash</span><br></pre></td></tr></table></figure>
<ul>
<li>-i: 交互式操作。</li>
<li>-t: 终端。</li>
<li>ubuntu:15.10: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</li>
<li>&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</li>
</ul>
<p><strong>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像（而如果你本地没有最新的镜像，则会自动拉取）。</strong></p>
<h1 id="查找远程镜像"><a href="#查找远程镜像" class="headerlink" title="查找远程镜像"></a>查找远程镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search mysql</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F.png" alt="查找镜像.png"></p>
<ul>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否 docker 官方发布</li>
<li>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li>AUTOMATED: 自动构建。</li>
</ul>
<h1 id="拉取远程镜像"><a href="#拉取远程镜像" class="headerlink" title="拉取远程镜像"></a>拉取远程镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull mysql:8.0.31</span><br></pre></td></tr></table></figure>

<h1 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rmi mysql:8.0.31s</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发包基石——LockSupport</title>
    <url>/2022/12/17/JUC%E5%B9%B6%E5%8F%91%E5%8C%85%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94LockSupport/</url>
    <content><![CDATA[<p>LockSupport是java.util.concurrent包中一个工具类，它为构建锁和同步器提供了基本的线程阻塞&#x2F;唤醒原语。JDK中我们熟悉的AQS同步器就使用了它来控制线程的阻塞和唤醒，当然还有其他的锁或同步器也会使用它。因此，LockSupport可以说是juc并发包的基石。</p>
<span id="more"></span>
<h1 id="LockSupport核心方法"><a href="#LockSupport核心方法" class="headerlink" title="LockSupport核心方法"></a>LockSupport核心方法</h1><p>我们知道，LockSupport最核心的功能就是阻塞&#x2F;唤醒线程，对应方法如下：</p>
<ul>
<li>park()：阻塞当前线程，直到获取到可用许可。</li>
<li>parkNanos(long)：阻塞当前线程，直到获取到可用许可。参数为最大等待时间，一旦超过最大等待时间也会解除阻塞。</li>
<li>parkUntil(long)：阻塞当前线程，直到获取到可用许可。参数为最后期限时间，一旦超过最后期限时间也会解除阻塞。</li>
<li>park(Object)：与park()方法同义，但指定了阻塞对象。</li>
<li>parkNanos(Object,long)：与parkNanos(long)同义，但指定了阻塞对象。</li>
<li>parkUntil(Object,long)：与parkUntil(long)同义，但指定了阻塞对象。</li>
<li>unpark(Thread)：将指定线程的许可置为可用，也就相当于唤醒了该线程。</li>
</ul>
<p><img src="/2022/12/17/JUC%E5%B9%B6%E5%8F%91%E5%8C%85%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94LockSupport/LockSupport.png" alt="LockSupport.png"></p>
<h1 id="LockSupport许可机制"><a href="#LockSupport许可机制" class="headerlink" title="LockSupport许可机制"></a>LockSupport许可机制</h1><p>在介绍核心方法时出现了一个高频的词——许可，那么什么是许可呢？其实很容易理解，线程成功拿到许可则能够往下执行，否则将进入阻塞状态。对于LockSupport使用的许可可看成是一种二元信号，该信号分有许可和无许可两种状态。每个线程都对应一个信号变量，当线程调用park时其实就是去获取许可，如果能成功获取到许可则能够往下执行，否则则阻塞直到成功获取许可为止。而当线程调用unpark时则是释放许可，供线程去获取。如下图所示，首先在线程t1和线程t2中调用park()，二者都进入阻塞状态。然后调用unpark(t1)，为线程t1颁发许可。那么线程t1将解除阻塞，恢复执行，同时将许可置为不可用（或者说消费许可）。<br><img src="/2022/12/17/JUC%E5%B9%B6%E5%8F%91%E5%8C%85%E5%9F%BA%E7%9F%B3%E2%80%94%E2%80%94LockSupport/park.png" alt="park.png"></p>
<blockquote>
<p>park()：尝试消费许可，如果消费失败，则阻塞<br>unpark(thread)：为指定线程颁发许可</p>
</blockquote>
<h2 id="park与unpark无顺序"><a href="#park与unpark无顺序" class="headerlink" title="park与unpark无顺序"></a>park与unpark无顺序</h2><p>按照我们通常的理解，线程应该是先阻塞(park)，然后再去唤醒(unpark)，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;park before unpark&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>park before unpark</p>
</blockquote>
<p>但是LockSupport同样支持先颁发许可(unpark)，然后再去消费(park)，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark before park&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>unpark before park</p>
</blockquote>
<h2 id="多次unpark相当于一次"><a href="#多次unpark相当于一次" class="headerlink" title="多次unpark相当于一次"></a>多次unpark相当于一次</h2><p>我们不能为同一个线程颁发多个许可，多次颁发的结果也只是让线程拥有一个许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        LockSupport.unpark(thread); <span class="comment">// 颁发许可</span></span><br><span class="line">        LockSupport.park(); <span class="comment">// 消费许可</span></span><br><span class="line"></span><br><span class="line">        LockSupport.park(); <span class="comment">// 此时无可用许可，则阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;no avail permit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与wait和notify-x2F-notifyAll异同"><a href="#与wait和notify-x2F-notifyAll异同" class="headerlink" title="与wait和notify&#x2F;notifyAll异同"></a>与wait和notify&#x2F;notifyAll异同</h1><p>在没有LockSupport之前，线程的阻塞和唤醒都是通过wait和notify&#x2F;notifyAll实现的，那么两种实现有什么区别呢？如下：</p>
<ol>
<li>wait和notify&#x2F;notifyAll只能在同步方法&#x2F;同步块中使用，而LockSupport可以在任何位置使用。<blockquote>
<p>LockSupport线程间不再需要维护同一个锁对象，实现了线程间的解耦</p>
</blockquote>
</li>
<li>wait和notify&#x2F;notifyAll必须得先wait阻塞，然后才能notify唤醒，而LockSupport则是无顺序的。<blockquote>
<p>unpark函数可以先于park调用，所以不需要担心线程间的执行的先后顺序</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>juc并发包</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之客户端连接那些事</title>
    <url>/2022/10/23/MySQL%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="Root用户忘记密码"><a href="#Root用户忘记密码" class="headerlink" title="Root用户忘记密码"></a>Root用户忘记密码</h1><ol>
<li>配置文件——my.cnf中添加：skip-grant-tables，保存退出；</li>
<li>重启mysql服务使配置文件生效：service mysqld restart；</li>
<li>mysql -uroot -p回车登录；</li>
<li>使用mysql数据库：use mysql；<span id="more"></span></li>
<li>将root密码置为空：update user set authentication_string &#x3D; ‘’ where user &#x3D; ‘root’;</li>
<li>my.cnf中删掉步骤1的语句——skip-grant-tables，重启mysql服务；</li>
<li>登录mysql，修改root用户密码：ALTER USER ‘root‘@’localhost’ IDENTIFIED with mysql_native_password BY ‘${password}’;</li>
</ol>
<h1 id="MySQL-8-连接失败：caching-sha2…"><a href="#MySQL-8-连接失败：caching-sha2…" class="headerlink" title="MySQL 8 连接失败：caching sha2…"></a>MySQL 8 连接失败：caching sha2…</h1><p>MySQL 8 之前的版本使用的密码加密规则是mysql_native_password，但是在mysql 8 则是caching_sha2_password，解决办法如下：</p>
<h2 id="修改加密规则"><a href="#修改加密规则" class="headerlink" title="修改加密规则"></a>修改加密规则</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL-8-客户端无法使用root用户登录"><a href="#MySQL-8-客户端无法使用root用户登录" class="headerlink" title="MySQL 8 客户端无法使用root用户登录"></a>MySQL 8 客户端无法使用root用户登录</h1><h2 id="root登录mysql"><a href="#root登录mysql" class="headerlink" title="root登录mysql"></a>root登录mysql</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br></pre></td></tr></table></figure>

<h2 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;liteng&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;liteng&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>客户端连接</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security——RememberMe</title>
    <url>/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/</url>
    <content><![CDATA[<h1 id="RememberMe简介"><a href="#RememberMe简介" class="headerlink" title="RememberMe简介"></a>RememberMe简介</h1><p>通常用户登录成功后，服务端会创建与之应的会话信息，也就是Session，用来保存其登录状态。但这个Session是有时效性的，比如5分钟。如果用户在这5分钟内没有任何操作的话，那么Session将会失效，用户再次访问则需要重新登录。诚然，这是出于安全考虑的一种设计。但有时候，这种频繁的登录会给我们带来苦恼。比如：PC通常只有个人使用。某天我们去浏览一个网站，然后起身上了个厕所，回来发现Sesssion失效了，重新登录一遍。过了一会，又起身接了杯水喝，回来发现Session又失效了，又得重新登录一遍，这是不是很麻烦？那么有没有一种办法，即使Session过期了，还能够保持登录状态呢？有，RememberMe就是为此而生的。RememberMe是一种服务器端的行为，其本质上和Session的类似，都是基于Cookie的实现的。</p>
<span id="more"></span>

<h2 id="不使用RememberMe现象"><a href="#不使用RememberMe现象" class="headerlink" title="不使用RememberMe现象"></a>不使用RememberMe现象</h2><p>不使用RememberMe，每次Session过期都需要重新登录，其现象如下：<br><img src="/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/session1.png" alt="session1.png"><br>然后我们登录，不勾选“记住我”，结果如下：<br><img src="/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/session2.png" alt="session2.png"><br>等待60s（我们配置的Session过期时间），再次访问，结果如下：<br><img src="/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/session3.png" alt="session3.png"></p>
<h2 id="使用RememberMe现象"><a href="#使用RememberMe现象" class="headerlink" title="使用RememberMe现象"></a>使用RememberMe现象</h2><p>使用RememberMe，即使Session过期也不需要重新登录，其现象如下：<br><img src="/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/session1.png" alt="session1.png"><br>然后我们登录，勾选“记住我”，结果如下：<br><img src="/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/session4.png" alt="session4.png"><br>然后立刻再次访问（60s之内），结果如下：<br><img src="/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/session5.png" alt="session5.png"><br>60s之后（Session已过期），再次访问，结果如下：<br><img src="/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/session6.png" alt="session6.png"></p>
<h1 id="RememberMe原理"><a href="#RememberMe原理" class="headerlink" title="RememberMe原理"></a>RememberMe原理</h1><h2 id="remember-me生成规则"><a href="#remember-me生成规则" class="headerlink" title="remember-me生成规则"></a>remember-me生成规则</h2><p>我们发现，当使用了RememberMe功能时，Cookie中多了一个<code>remember-me</code>。它同样是由服务端生成的，具体规则如下：</p>
<ol>
<li>登录成功，生成一条记录（包含用户名、随机生成的序列号、token）。<blockquote>
<p>如果基于数据库存储RememberMe的话，如下：<br><img src="/2022/12/30/Spring%20Security%E2%80%94%E2%80%94RememberMe/RememberMe.png" alt="RememberMe.png"></p>
</blockquote>
</li>
<li>将username、series以及token加密处理，生成remember-me。</li>
</ol>
<h2 id="RememberMe访问流程"><a href="#RememberMe访问流程" class="headerlink" title="RememberMe访问流程"></a>RememberMe访问流程</h2><ol>
<li>使用RememberMe登录，登录成功</li>
<li>服务端生成Session和RememberMe</li>
<li>浏览器Cookie存储Session和RememberMe</li>
<li>浏览器访问资源，请求头携带Session和RememberMe</li>
<li>服务端验证Session，如果验证成功（Session未过期），访问通过</li>
<li>如果Session过期，则验证RememberMe，如果验证成功（RememberMe未过期），则访问通过</li>
<li>服务端重新生成Session和RememberMe</li>
<li>浏览器Cookie刷新Session和RememberMe</li>
<li>如果RememberMe过期，则需要重新登录</li>
</ol>
<h1 id="RememberMe使用"><a href="#RememberMe使用" class="headerlink" title="RememberMe使用"></a>RememberMe使用</h1><h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> persistent_logins (</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">    series <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">primary</span> key, </span><br><span class="line">    token <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">    last_used <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="配置RememberMe"><a href="#配置RememberMe" class="headerlink" title="配置RememberMe"></a>配置RememberMe</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记住我</span></span><br><span class="line">        http.rememberMe()</span><br><span class="line">                .tokenRepository(persistentTokenRepository())</span><br><span class="line">                .tokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                .userDetailsService(myUserDetailsService);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersistentTokenRepository <span class="title function_">persistentTokenRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RememberMe失效"><a href="#RememberMe失效" class="headerlink" title="RememberMe失效"></a>RememberMe失效</h1><ol>
<li>过期自动失效</li>
<li>退出登录立即失效</li>
</ol>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Session</tag>
        <tag>RememberMe</tag>
        <tag>会话管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security——会话（Session）管理</title>
    <url>/2022/12/27/Spring%20Security%E2%80%94%E2%80%94%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>用户认证通过后，为了避免之后的每次操作都进行重复认证，可将用户的信息保存在会话中。spring security提供会话管理，认证通过后可将身份信息放入SecurityContextHolder上下文，SecurityContext与当前线程进行绑定，方便获取用户身份。</p>
<h1 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world.&quot;</span> + getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!authentication.isAuthenticated()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> authentication.getPrincipal();</span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails) &#123;</span><br><span class="line">            username = ((UserDetails) principal).getUsername();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            username = principal.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h1><p>我们可以通过以下选项准确控制会话何时创建以及Spring Security如何与之交互：</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>总是创建一个HttpSession</td>
</tr>
<tr>
<td>ifRequired</td>
<td>Spring Security 仅仅将会在必要的时候创建一个HttpSession（默认）</td>
</tr>
<tr>
<td>never</td>
<td>Spring Security将永远不会创建一个HttpSession。但是如果已经存在一个HttpSession的话，Spring Security将会使用它</td>
</tr>
<tr>
<td>stateless</td>
<td>Spring Security将永远不会创建一个HttpSession，也不使用它。并且它会暗示不使用cookie，所以每个请求都需要重新进行身份认证。这种无状态架构适用于REST API及其无状态认证机制</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="会话超时"><a href="#会话超时" class="headerlink" title="会话超时"></a>会话超时</h1><p>可以在servlet容器中设置Session的超时时间，如下设置Session有效期为600s：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">session:</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">600s</span></span><br></pre></td></tr></table></figure>
<p>session超时时间最低为60s，参考Tomcat源码<code>TomcatServletWebServerFactory#configureSession</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getSessionTimeoutInMinutes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Duration</span> <span class="variable">sessionTimeout</span> <span class="operator">=</span> getSession().getTimeout();</span><br><span class="line">    <span class="keyword">if</span> (isZeroOrLess(sessionTimeout)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sessionTimeout.toMinutes(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>session超时之后，可以通过Spring Security设置跳转的路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.sessionManagement().invalidSessionUrl(<span class="string">&quot;/session/invalid&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还需要将&quot;/session/invalid&quot;放行</span></span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/login.html&quot;</span>, <span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;/error.html&quot;</span>, <span class="string">&quot;/login/toError&quot;</span>, <span class="string">&quot;/session/invalid&quot;</span>).permitAll()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/session&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/invalid&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;session invalid.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：重启完服务，首次访问<code>/login.html</code>时，由于此时服务器还没有session，因此会跳转到<code>/session/invalid</code>。同时首次请求，服务器将会创建一个空session（无用户信息），所以第二次访问时将会跳转到登录页。</p>
</blockquote>
<h1 id="会话并发控制"><a href="#会话并发控制" class="headerlink" title="会话并发控制"></a>会话并发控制</h1><p>当用户在一个浏览器登录后，又尝试在另一个浏览器登录相同的账户。为了不让用户无限制的登录，可以有以下两种处理方法：</p>
<ol>
<li>后登录的将先登录的挤兑下线</li>
<li>当登录到达上限后，禁止再登录</li>
</ol>
<h2 id="挤兑下线"><a href="#挤兑下线" class="headerlink" title="挤兑下线"></a>挤兑下线</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.formLogin(); <span class="comment">// 使用原始的登录页面</span></span><br><span class="line"></span><br><span class="line">    http.sessionManagement()</span><br><span class="line">            .maximumSessions(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法：</p>
<ol>
<li>首先用Chrom浏览器登录账户liteng</li>
<li>然后用FireFox浏览器登录账户liteng</li>
<li>然后再用Chrom浏览器访问主页<code>/main.html</code></li>
</ol>
<p>测试结果：<br><code>This session has been expired (possibly due to multiple concurrent logins being attempted as the same user).</code>这是<code>ResponseBodySessionInformationExpiredStrategy</code>的默认实现。<br><img src="/2022/12/27/Spring%20Security%E2%80%94%E2%80%94%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89%E7%AE%A1%E7%90%86/SessionInformationExpiredStrategy.png" alt="SessionInformationExpiredStrategy.png"><br>我们还可以自定义实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySessionInformationExpiredStrategy</span> <span class="keyword">implements</span> <span class="title class_">SessionInformationExpiredStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onExpiredSessionDetected</span><span class="params">(SessionInformationExpiredEvent event)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> event.getResponse();</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;您已被挤兑下线！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.sessionManagement()</span><br><span class="line">            .maximumSessions(<span class="number">1</span>)</span><br><span class="line">            .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">MySessionInformationExpiredStrategy</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：<br><img src="/2022/12/27/Spring%20Security%E2%80%94%E2%80%94%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89%E7%AE%A1%E7%90%86/%E6%8C%A4%E5%85%91%E4%B8%8B%E7%BA%BF.png" alt="挤兑下线.png"></p>
<h2 id="禁止登录"><a href="#禁止登录" class="headerlink" title="禁止登录"></a>禁止登录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.formLogin(); <span class="comment">// 使用原始的登录页面</span></span><br><span class="line"></span><br><span class="line">    http.sessionManagement()</span><br><span class="line">            .maximumSessions(<span class="number">1</span>)</span><br><span class="line">            .maxSessionsPreventsLogin(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法：</p>
<ol>
<li>首先用Chrom浏览器访问主页<code>/main.html</code>，跳转登录页，登录账户liteng</li>
<li>然后用FireFox浏览器访问主页<code>/main.html</code>，跳转登录页，登录账户liteng</li>
</ol>
<p>测试结果：<br><img src="/2022/12/27/Spring%20Security%E2%80%94%E2%80%94%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89%E7%AE%A1%E7%90%86/%E7%A6%81%E6%AD%A2%E7%99%BB%E5%BD%95.png" alt="禁止登录.png"></p>
<h1 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h1><p>实际生产中，一个服务往往是多实例的，并通过Nginx做负载均衡，将请求分发到不同的实例上。这就会存在分布式Session的问题：假设有1和2两个实例，由Nginx轮询分发请求。此时用户请求<code>/main.html</code>，触发登录，然后服务端将会创建Session。我们假设此次请求被分发到实例1上，理所应当地，Session也将会存储在实例1上。然后用户再次访问<code>/main.html</code>，这次的请求被分配到实例2上，由于实例2并不存在Session，因此会再次触发登录，这对于用户来说是不合理的现象。<br><img src="/2022/12/27/Spring%20Security%E2%80%94%E2%80%94%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89%E7%AE%A1%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8FSession1.png" alt="分布式Session1.png"><br>解决这个问题的思路是用户登录的会话信息不再存储到某个具体的服务实例中，而是保存到另一个第三方介质中，比如redis、mongodb等。所有的服务实例都从这个第三方介质来获取Session信息。比如：用户在实例1上登录，然后将会话信息保存到redis中，用户的下次请求被分配到实例2上，实例2再从redis中检查Session是否已经存在，如果存在就不用再登录，可以直接访问服务了。<br><img src="/2022/12/27/Spring%20Security%E2%80%94%E2%80%94%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89%E7%AE%A1%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8FSession2.png" alt="分布式Session2.png"><br>具体做法如下：</p>
<ol>
<li>引入Spring Session依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置Session存储方式<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">store-type:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.175</span><span class="number">.175</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>测试分布式Session：</p>
<ol>
<li>8080端口启动服务</li>
<li>8081端口启动服务</li>
<li>访问<code>http://localhost:8080/main.html</code>，触发登录</li>
<li>访问<code>http://localhost:8081/main.html</code>，直接访问</li>
</ol>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Session</tag>
        <tag>会话管理</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security——初体验</title>
    <url>/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>关于Spring Security的介绍我们不做过多赘述，下面是Spring官网对其描述：</p>
<blockquote>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework.  It is the de-facto standard for securing Spring-based applications.<br>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是保护基于spring的应用程序的事实上的标准。</p>
</blockquote>
<p>我们直接开始Spring Security的使用（注：本篇只介绍入门使用，旨在让大家对Spring Security有一个简单的认知）！</p>
<blockquote>
<p>本系列均以与SpringBoot的集成为例进行演示</p>
</blockquote>
<span id="more"></span>

<h1 id="接口准备"><a href="#接口准备" class="headerlink" title="接口准备"></a>接口准备</h1><p>创建SpringBoot工程，仅引入Web模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后提供一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="未集成Spring-Security的接口访问"><a href="#未集成Spring-Security的接口访问" class="headerlink" title="未集成Spring Security的接口访问"></a>未集成Spring Security的接口访问</h1><p>浏览器访问接口<code>http://localhost:8080/test/hello</code>，直接返回响应结果：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/hello1.png" alt="hello1.png"></p>
<h1 id="集成Spring-Security的接口访问"><a href="#集成Spring-Security的接口访问" class="headerlink" title="集成Spring Security的接口访问"></a>集成Spring Security的接口访问</h1><p>然后我们引入Security模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再次浏览器访问接口<code>http://localhost:8080/test/hello</code>，结果如下：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/login.png" alt="login.png"><br>可以看到，我们的接口已经被保护起来了！想要访问，就必须进行登录。而登录需要用户名和密码，下面我们介绍几种获取用户名和密码的方式。</p>
<h2 id="默认用户名密码"><a href="#默认用户名密码" class="headerlink" title="默认用户名密码"></a>默认用户名密码</h2><p>Spring Security提供了默认的用户名和密码，用户名固定为<code>user</code>，密码则是在SpringBoot启动时随机生成，并且打印到控制台了：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/DefaultPassword.png" alt="DefaultPassword.png"><br>我们尝试登录：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/tryLogin1.png" alt="tryLogin1.png"><br>登录成功：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/hello1.png" alt="hello1.png"><br>这里我们注意一下默认密码是由<code>UserDetailsServiceAutoConfiguration</code>提供的，该类核心逻辑为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(AuthenticationManager.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ObjectPostProcessor.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">		value = &#123; AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class, AuthenticationManagerResolver.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Lazy</span></span><br><span class="line">	<span class="keyword">public</span> InMemoryUserDetailsManager <span class="title function_">inMemoryUserDetailsManager</span><span class="params">(SecurityProperties properties,</span></span><br><span class="line"><span class="params">			ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder)</span> &#123;</span><br><span class="line">		SecurityProperties.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> properties.getUser();</span><br><span class="line">		List&lt;String&gt; roles = user.getRoles();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(</span><br><span class="line">				User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))</span><br><span class="line">						.roles(StringUtils.toStringArray(roles)).build());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBoot启动的时候，该类会自动装配一个<code>InMemoryUserDetailsManager</code>类型的Bean到Spring容器中，而该Bean则在其内存中维护了一个用户信息。该用户信息又来自配置类<code>SecurityProperties</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.security&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.user;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Default user name.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Password for the default user name.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，默认用户名为user，默认密码是一个随机生成的UUID。</p>
<h2 id="基于配置文件方式"><a href="#基于配置文件方式" class="headerlink" title="基于配置文件方式"></a>基于配置文件方式</h2><p>知道了默认用户名和密码的本质，我们就理所应当地知道了可以通过配置文件的方式自定义用户名和密码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>我们尝试登录：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/tryLogin2.png" alt="tryLogin2.png"><br>登录成功：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/hello1.png" alt="hello1.png"></p>
<h2 id="自定义UserDetailsService"><a href="#自定义UserDetailsService" class="headerlink" title="自定义UserDetailsService"></a>自定义UserDetailsService</h2><p>我们再回过头去看下<code>UserDetailsServiceAutoConfiguration</code>，它有一个注解<code>@ConditionalOnMissingBean(value = &#123; AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class, AuthenticationManagerResolver.class &#125;)</code>。该注解的意思是当Spring容器中不存在<code>AuthenticationManager</code>、<code>AuthenticationProvider</code>、<code>UserDetailsService</code>、<code>AuthenticationManagerResolver</code>类型的Bean时，该自动装配类才会起作用。换句话说，如果Spring容器中存在四种中的任意一种，该类则不会起作用。我们看一下<code>UserDetailsService</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">	UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类的作用是通过用户名加载用户信息。再进一步说明一下，有了该类就不再提供默认的用户名和密码了。换而言之，通过该类我们可以自定义用户信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// &quot;&#123;noop&#125;&quot;：不加密</span></span><br><span class="line">        <span class="keyword">return</span> User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123456&quot;</span>).authorities(AuthorityUtils.NO_AUTHORITIES).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们尝试登录：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/tryLogin3.png" alt="tryLogin3.png"><br>登录成功：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/hello1.png" alt="hello1.png"></p>
<h2 id="自定义UserDetailsManager"><a href="#自定义UserDetailsManager" class="headerlink" title="自定义UserDetailsManager"></a>自定义UserDetailsManager</h2><p>其实<code>UserDetailsManager</code>本质上也是<code>UserDetailsService</code>，这点从Java类图就能看出来：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/UserDetailsManager.png" alt="UserDetailsManager.png"><br>有时候我们也可以通过自定义<code>UserDetailsManager</code>来实现自定义用户名密码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsManager</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsManager</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, UserDetails&gt; users = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User</span><br><span class="line">                .withUsername(<span class="string">&quot;wangwu&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;&#123;noop&#125;123456&quot;</span>)</span><br><span class="line">                .authorities(AuthorityUtils.NO_AUTHORITIES).build();</span><br><span class="line">        users.put(<span class="string">&quot;wangwu&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(UserDetails user)</span> &#123;</span><br><span class="line">        users.putIfAbsent(user.getUsername(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserDetails user)</span> &#123;</span><br><span class="line">        users.put(user.getUsername(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        users.remove(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldPassword, String newPassword)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">if</span> (currentUser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This would indicate bad coding somewhere</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(</span><br><span class="line">                    <span class="string">&quot;Can&#x27;t change password as no Authentication object found in context &quot;</span> + <span class="string">&quot;for current user.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> currentUser.getName();</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="built_in">this</span>.users.get(username);</span><br><span class="line">        Assert.state(userDetails != <span class="literal">null</span>, <span class="string">&quot;Current user doesn&#x27;t exist in database.&quot;</span>);</span><br><span class="line">        <span class="comment">// 自行实现修改密码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">userExists</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> users.containsKey(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> users.get(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们尝试登录：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/tryLogin4.png" alt="tryLogin4.png"><br>登录成功：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/hello1.png" alt="hello1.png"></p>
<h2 id="基于配置类WebSecurityConfigurerAdapter"><a href="#基于配置类WebSecurityConfigurerAdapter" class="headerlink" title="基于配置类WebSecurityConfigurerAdapter"></a>基于配置类WebSecurityConfigurerAdapter</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 指定UserDetailsService</span></span><br><span class="line">        auth.userDetailsService(myUserDetailsService);</span><br><span class="line">        <span class="comment">// 使用内存方式预置一个用户</span></span><br><span class="line"><span class="comment">//        auth.inMemoryAuthentication()</span></span><br><span class="line"><span class="comment">//                .withUser(&quot;lisi&quot;)</span></span><br><span class="line"><span class="comment">//                .password(&quot;&#123;noop&#125;123456&quot;)</span></span><br><span class="line"><span class="comment">//                .authorities(AuthorityUtils.NO_AUTHORITIES);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们尝试登录：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/tryLogin3.png" alt="tryLogin3.png"><br>登录成功：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E5%88%9D%E4%BD%93%E9%AA%8C/hello1.png" alt="hello1.png"></p>
<h1 id="Spring-Security密码加密器"><a href="#Spring-Security密码加密器" class="headerlink" title="Spring Security密码加密器"></a>Spring Security密码加密器</h1><p>通常使用Spring Security时是需要对密码进行加密处理的，密码加密器的种类有很多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PasswordEncoderFactories</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">PasswordEncoderFactories</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> PasswordEncoder <span class="title function_">createDelegatingPasswordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">encodingId</span> <span class="operator">=</span> <span class="string">&quot;bcrypt&quot;</span>;</span><br><span class="line">		Map&lt;String, PasswordEncoder&gt; encoders = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		encoders.put(encodingId, <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>());</span><br><span class="line">		encoders.put(<span class="string">&quot;ldap&quot;</span>, <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.crypto.password.LdapShaPasswordEncoder());</span><br><span class="line">		encoders.put(<span class="string">&quot;MD4&quot;</span>, <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.crypto.password.Md4PasswordEncoder());</span><br><span class="line">		encoders.put(<span class="string">&quot;MD5&quot;</span>, <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="string">&quot;MD5&quot;</span>));</span><br><span class="line">		encoders.put(<span class="string">&quot;noop&quot;</span>, org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance());</span><br><span class="line">		encoders.put(<span class="string">&quot;pbkdf2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>());</span><br><span class="line">		encoders.put(<span class="string">&quot;scrypt&quot;</span>, <span class="keyword">new</span> <span class="title class_">SCryptPasswordEncoder</span>());</span><br><span class="line">		encoders.put(<span class="string">&quot;SHA-1&quot;</span>, <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="string">&quot;SHA-1&quot;</span>));</span><br><span class="line">		encoders.put(<span class="string">&quot;SHA-256&quot;</span>,</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="string">&quot;SHA-256&quot;</span>));</span><br><span class="line">		encoders.put(<span class="string">&quot;sha256&quot;</span>, <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.crypto.password.StandardPasswordEncoder());</span><br><span class="line">		encoders.put(<span class="string">&quot;argon2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Argon2PasswordEncoder</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatingPasswordEncoder</span>(encodingId, encoders);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>noop</code>代表不加密，推荐使用<code>bcrypt</code>，指定密码加密器的方式有两种。</p>
<h2 id="通过前缀指定"><a href="#通过前缀指定" class="headerlink" title="通过前缀指定"></a>通过前缀指定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">encodePwd</span> <span class="operator">=</span> bCryptPasswordEncoder.encode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;&#123;bcrypt&#125;&quot;</span> + encodePwd).authorities(AuthorityUtils.NO_AUTHORITIES).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过注入Bean指定"><a href="#通过注入Bean指定" class="headerlink" title="通过注入Bean指定"></a>通过注入Bean指定</h2><p>往Spring容器中注册<code>BCryptPasswordEncoder</code>密码加密器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSecurityStudyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringSecurityStudyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); <span class="comment">// bcrypt加密</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring容器中但凡有<code>PasswordEncoder</code>类型的Bean，就会被作为默认的密码加密器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(passwordEncoder.encode(<span class="string">&quot;123456&quot;</span>)).authorities(AuthorityUtils.NO_AUTHORITIES).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>Spring</tag>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security——数据库认证</title>
    <url>/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>在上一篇中我们介绍了多种<code>Spring Security</code>配置用户名密码的方式，但那些都是基于内存的，实际生产中用户信息往往存储在数据库中，因此本篇我们来学习如何基于数据库实现认证。</p>
<h1 id="RBAC相关模型设计"><a href="#RBAC相关模型设计" class="headerlink" title="RBAC相关模型设计"></a>RBAC相关模型设计</h1><p>RBAC——Role Based Access Control，基于角色的访问控制。通常设计5张表：用户表、角色表、权限表、用户角色关系表以及角色权限关系表，具体表结构如下：</p>
<span id="more"></span>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for permissions</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `permissions`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `permissions`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `parent_id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `en_name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `url` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">7</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;权限&#x27;</span> ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of permissions</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permissions` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;系统管理&#x27;</span>, <span class="string">&#x27;SYSTEM_MANAGE&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permissions` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;用户管理&#x27;</span>, <span class="string">&#x27;USER_MANAGE&#x27;</span>, <span class="string">&#x27;/user&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permissions` <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;查看用户&#x27;</span>, <span class="string">&#x27;USER_VIEW&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permissions` <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">2</span>, <span class="string">&#x27;新增用户&#x27;</span>, <span class="string">&#x27;USER_ADD&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permissions` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">2</span>, <span class="string">&#x27;修改用户&#x27;</span>, <span class="string">&#x27;USER_MODIFY&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permissions` <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">2</span>, <span class="string">&#x27;删除用户&#x27;</span>, <span class="string">&#x27;USER_REMOVE&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for role</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `role`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `parent_id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `en_name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">2</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;角色&#x27;</span> ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of role</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;超级管理员&#x27;</span>, <span class="string">&#x27;SUPER_ADMIN&#x27;</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for role_permissions</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `role_permissions`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role_permissions`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `permissions_id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">7</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of role_permissions</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permissions` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permissions` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permissions` <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permissions` <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permissions` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permissions` <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `uniq_username`(`username`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `uniq_phone`(`phone`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `uniq_email`(`email`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">29</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;用户&#x27;</span> ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;liteng&#x27;</span>, <span class="string">&#x27;$2a$10$dRQvD0SVK2KcA4eXQYPR.ODP.RlmvddP5HEcjdoQ7y.JF.rTHph3u&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for user_role</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `user_role`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">2</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of user_role</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_role` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="引入持久层依赖——MyBatis"><a href="#引入持久层依赖——MyBatis" class="headerlink" title="引入持久层依赖——MyBatis"></a>引入持久层依赖——MyBatis</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.175.175:3306/zookeeper?useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">liteng</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h1 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long parentId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String enName;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permissions</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long parentId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String enName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建Mapper"><a href="#创建Mapper" class="headerlink" title="创建Mapper"></a>创建Mapper</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PermissionsMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;\tid, \n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;\tparent_id as parentId, \n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;\tname, \n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;\ten_name as enName, \n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;\turl, \n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;\tdescription \n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;FROM\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;\tpermissions \n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;WHERE\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;\tid IN ( SELECT permissions_id FROM role_permissions WHERE role_id IN ( SELECT role_id FROM user_role WHERE user_id = #&#123;id&#125; ) )&quot;)</span></span><br><span class="line">    List&lt;Permissions&gt; <span class="title function_">selectByUserId</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指定Mapper扫描路径"><a href="#指定Mapper扫描路径" class="headerlink" title="指定Mapper扫描路径"></a>指定Mapper扫描路径</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.stockeeper.spring.security.study.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSecurityStudyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringSecurityStudyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义数据库认证逻辑"><a href="#自定义数据库认证逻辑" class="headerlink" title="自定义数据库认证逻辑"></a>自定义数据库认证逻辑</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PermissionsMapper permissionsMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Permissions&gt; permissionsList = permissionsMapper.selectByUserId(user.getId());</span><br><span class="line">        permissionsList.forEach(permissions -&gt; authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(permissions.getEnName())));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> org.springframework.security.core.userdetails.User.withUsername(username).password(user.getPassword()).authorities(authorities).build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WebSecurityConfigurerAdapter配置"><a href="#WebSecurityConfigurerAdapter配置" class="headerlink" title="WebSecurityConfigurerAdapter配置"></a>WebSecurityConfigurerAdapter配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); <span class="comment">// bcrypt加密</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.userDetailsService(myUserDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>Spring</tag>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security——自定义登录页面</title>
    <url>/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="相关页面准备"><a href="#相关页面准备" class="headerlink" title="相关页面准备"></a>相关页面准备</h1><p><code>src/main/resources/static/</code>下准备如下页面：<br>登录页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>主页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">登录成功！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>登陆失败页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">登录失败！<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/login.html&quot;</span>&gt;</span>重新登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="HttpSecurity配置"><a href="#HttpSecurity配置" class="headerlink" title="HttpSecurity配置"></a>HttpSecurity配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); <span class="comment">// bcrypt加密</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.userDetailsService(myUserDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 认证</span></span><br><span class="line">        http.formLogin()                                <span class="comment">// 表单提交</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;username&quot;</span>)          <span class="comment">// 指定用户名对应的input框的name属性值，默认为username</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)          <span class="comment">// 指定密码对应的input框的name属性值，password</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/login.html&quot;</span>)               <span class="comment">// 自定义登录页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/user/login&quot;</span>)      <span class="comment">// 登录请求路径，自定义，但必须和表单的action属性值保持一致</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/main.html&quot;</span>)        <span class="comment">// a.登录成功后默认重定向的地址（记忆原始请求路径）</span></span><br><span class="line">                .failureUrl(<span class="string">&quot;/error.html&quot;</span>);             <span class="comment">// a.登录失败后重定向的地址</span></span><br><span class="line"><span class="comment">//                .successForwardUrl(&quot;/login/toMain&quot;)     // b.登录成功后转发的地址</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/login/toError&quot;);   // b.登录失败后转发的地址</span></span><br><span class="line"><span class="comment">//                .successHandler(new MyAuthenticationSuccessHandler(&quot;/main.html&quot;))   // c.自定义登录成功处理器</span></span><br><span class="line"><span class="comment">//                .failureHandler(new MyAuthenticationFailureHandler(&quot;/error.html&quot;)); // c.自定义登录失败处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 授权</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login.html&quot;</span>, <span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;/error.html&quot;</span>, <span class="string">&quot;/login/toError&quot;</span>).permitAll() <span class="comment">// 不需要登录认证的请求</span></span><br><span class="line">                .anyRequest().authenticated()   <span class="comment">// 其他请求全部需要登录认证</span></span><br><span class="line">                .and().csrf().disable();        <span class="comment">// 禁用跨站请求伪造保护</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h1><p><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/tryLogin5.png" alt="tryLogin5.png"><br>登录成功：<br><img src="/2022/12/22/Spring%20Security%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/hello2.png" alt="hello2.png"></p>
<h1 id="defaultSuccessUrl方法解析"><a href="#defaultSuccessUrl方法解析" class="headerlink" title="defaultSuccessUrl方法解析"></a>defaultSuccessUrl方法解析</h1><p><code>defaultSuccessUrl(String url)</code>和<code>failureUrl(String url)</code>指定了登录成功或者失败后<strong>重定向</strong>的地址，我们以<code>defaultSuccessUrl(String url)</code>为例进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title function_">defaultSuccessUrl</span><span class="params">(String defaultSuccessUrl)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultSuccessUrl(defaultSuccessUrl, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title function_">defaultSuccessUrl</span><span class="params">(String defaultSuccessUrl, <span class="type">boolean</span> alwaysUse)</span> &#123;</span><br><span class="line">    <span class="comment">// 这一行是关键，指定了登录成功处理器——保存了请求意识的登录成功处理器</span></span><br><span class="line">    <span class="type">SavedRequestAwareAuthenticationSuccessHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span>();</span><br><span class="line">    handler.setDefaultTargetUrl(defaultSuccessUrl);</span><br><span class="line">    handler.setAlwaysUseDefaultTargetUrl(alwaysUse);</span><br><span class="line">    <span class="built_in">this</span>.defaultSuccessHandler = handler;</span><br><span class="line">    <span class="keyword">return</span> successHandler(handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleUrlAuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">RequestCache</span> <span class="variable">requestCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpSessionRequestCache</span>();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">		<span class="type">SavedRequest</span> <span class="variable">savedRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.requestCache.getRequest(request, response); <span class="comment">// 原始请求</span></span><br><span class="line">		<span class="keyword">if</span> (savedRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">targetUrlParameter</span> <span class="operator">=</span> getTargetUrlParameter();</span><br><span class="line">		<span class="keyword">if</span> (isAlwaysUseDefaultTargetUrl()</span><br><span class="line">				|| (targetUrlParameter != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(request.getParameter(targetUrlParameter)))) &#123;</span><br><span class="line">			<span class="built_in">this</span>.requestCache.removeRequest(request, response);</span><br><span class="line">			<span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		clearAuthenticationAttributes(request);</span><br><span class="line">		<span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> savedRequest.getRedirectUrl(); <span class="comment">// 原始请求路径</span></span><br><span class="line">		getRedirectStrategy().sendRedirect(request, response, targetUrl);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRequestCache</span><span class="params">(RequestCache requestCache)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.requestCache = requestCache;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的一点就是<code>defaultSuccessUrl(String url)</code>会记忆原始请求，并在登录成功后自动重定向到我们初始访问时的请求路径。</p>
</blockquote>
<h1 id="successForwardUrl方法解析"><a href="#successForwardUrl方法解析" class="headerlink" title="successForwardUrl方法解析"></a>successForwardUrl方法解析</h1><p><code>successForwardUrl(String url)</code>和<code>failureForwardUrl(String url)</code>指定了登录成功或者失败后<strong>转发</strong>的地址，我们以<code>successForwardUrl(String url)</code>为例进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FormLoginConfigurer&lt;H&gt; <span class="title function_">successForwardUrl</span><span class="params">(String forwardUrl)</span> &#123;</span><br><span class="line">    <span class="comment">// 这一行是关键，指定了登录成功处理器——转发处理器</span></span><br><span class="line">    successHandler(<span class="keyword">new</span> <span class="title class_">ForwardAuthenticationSuccessHandler</span>(forwardUrl));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForwardAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String forwardUrl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> forwardUrl</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ForwardAuthenticationSuccessHandler</span><span class="params">(String forwardUrl)</span> &#123;</span><br><span class="line">		Assert.isTrue(UrlUtils.isValidRedirectUrl(forwardUrl), () -&gt; <span class="string">&quot;&#x27;&quot;</span> + forwardUrl + <span class="string">&quot;&#x27; is not a valid forward URL&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.forwardUrl = forwardUrl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">			Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">		request.getRequestDispatcher(<span class="built_in">this</span>.forwardUrl).forward(request, response); <span class="comment">// 直接转发请求到指定路径</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义登录成功-x2F-失败处理器"><a href="#自定义登录成功-x2F-失败处理器" class="headerlink" title="自定义登录成功&#x2F;失败处理器"></a>自定义登录成功&#x2F;失败处理器</h1><h2 id="登录成功处理器"><a href="#登录成功处理器" class="headerlink" title="登录成功处理器"></a>登录成功处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String redirectUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAuthenticationSuccessHandler</span><span class="params">(String redirectUrl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redirectUrl = redirectUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 重定向</span></span><br><span class="line">        response.sendRedirect(redirectUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="登录失败处理器"><a href="#登录失败处理器" class="headerlink" title="登录失败处理器"></a>登录失败处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String redirectUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAuthenticationFailureHandler</span><span class="params">(String redirectUrl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redirectUrl = redirectUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 重定向</span></span><br><span class="line">        response.sendRedirect(redirectUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>Spring</tag>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper分布式锁原理</title>
    <url>/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Zookeeper分布式锁简单实现"><a href="#Zookeeper分布式锁简单实现" class="headerlink" title="Zookeeper分布式锁简单实现"></a>Zookeeper分布式锁简单实现</h1><p>Zookeeper分布式锁的原理很简单，核心就是依托Zookeeper节点唯一性来展开实现的。<br><img src="/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/%E8%8A%82%E7%82%B9%E5%94%AF%E4%B8%80%E6%80%A7.png" alt="节点唯一性.png"></p>
<span id="more"></span>
<p>具体来说：假如有10个线程同时创建节点<code>/lock</code>（前提是该节点不存在），肯定只有1个线程（T1）能创建成功，其余的9个线程(T2 ~ T10)创建失败（失败并不灰心，它们要监听<code>/lock</code>节点的删除事件，以便于后续的尝试）。我们就说线程T1获得了锁，获得了执行后续操作的权利。当线程T1执行完后续操作之后，它就会将<code>/lock</code>节点删除，于此同时线程T2 ~ T10得到通知，便一股脑的都去请求Zookeeper服务端，尝试获取锁（也就是创建节点<code>/lock</code>）。一样的，这次还是只有一个线程能成功获取到锁，执行完后续操作之后再将锁释放，如此周而复始，实现并发请求的串行化。该原理流程图如下：<br><img src="/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.png" alt="简单实现.png"></p>
<blockquote>
<p>基于以上原理的Zookeeper分布式锁简单实现其实存在一些弊端，比如：非公平锁和羊群效应</p>
</blockquote>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>经过以上分析我们可以发现一个问题：那就是每次在争抢锁的时候，大家获得锁的概率是随机的，并没有一个先来后到的机制，也就是所谓的不公平。比如：线程T1首先获得了锁，然后线程T2、T3……T9、T10依次来请求获取锁。但是当线程T1释放锁之后，并不是由线程T2直接接棒，而是大家同时争抢，谁抢到了算谁的。假如此刻线程T10抢到了，是不是对其余线程来说就很不公平。</p>
<h2 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h2><p>我们想一个问题：每次当一个线程将锁释放之后发生了什么事情呢？答案：其余线程得到通知，然后一股脑的都向Zookeeper服务端发送创建节点请求，但是最终只有一个线程创建成功。我们思考一下，这会带来一个什么问题呢？这样，我们假设有10000并发，第一次争抢锁时会有10000个请求打到Zookeeper服务端，第二次会有9999，第三次会有9998……当最终这10000的并发全部执行完，Zookeeper服务端处理了多少请求呢？等差数列：（10000 + 1） * 10000 &#x2F; 2 &#x3D; 50005000，而且其中只有10000个请求是有效的，这无形之中给Zookeeper服务端带来了巨大的压力，也浪费了服务器的资源。</p>
<blockquote>
<p>羊群效应：一群羊在羊圈外边吃草，突然来了一只狼。羊们害怕极了，都抢着往羊圈里跑。但是羊圈的入口只有一个，大家都挤到了一起，谁都不让谁。就这样，羊入圈的效率极其低下，白白牺牲了好多羊。</p>
</blockquote>
<h1 id="Zookeeper分布式锁进阶实现"><a href="#Zookeeper分布式锁进阶实现" class="headerlink" title="Zookeeper分布式锁进阶实现"></a>Zookeeper分布式锁进阶实现</h1><p>Zookeeper的进阶实现巧妙地规避了简单实现的两个问题：非公平和羊群效应。其实现原理大致分为如下几步：</p>
<ol>
<li>首先判断父节点<code>/lock</code>是否存在，如果不存在，则创建（容器）父节点</li>
<li>然后在父节点下创建（临时序号）子节点<code>/x-000000n</code></li>
<li>判断自己是不是父节点下的最小子结点<br> 3.1 如果是，则获取锁<br> 3.2 如果不是，则监听前一个节点</li>
<li>获得锁的节点完成业务处理，释放锁，即删除节点</li>
<li>前一个节点得到通知，重复第3步的判断</li>
<li>某客户端由于异常原因导致断开连接，其所对应的子结点自动删除，其后一个节点得到通知，重复第3步的判断</li>
<li>所有子结点均删除，（容器）父节点自动删除</li>
</ol>
<p>该原理的流程图如下：<br><img src="/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/%E8%BF%9B%E9%98%B6%E5%AE%9E%E7%8E%B0.png" alt="进阶实现.png"><br>该过程对应的Zookeeper节点结构如下：<br><img src="/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84.png" alt="节点结构.png"></p>
<h1 id="Curator实现分布式锁源码分析"><a href="#Curator实现分布式锁源码分析" class="headerlink" title="Curator实现分布式锁源码分析"></a>Curator实现分布式锁源码分析</h1><h2 id="锁的实例化"><a href="#锁的实例化" class="headerlink" title="锁的实例化"></a>锁的实例化</h2><p><img src="/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/%E9%94%81%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.png" alt="锁的实例化.png"><br>实例化完成之后的锁如下：<br><img src="/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/%E9%94%81%E5%AE%9E%E4%BE%8B.png" alt="锁实例.png"></p>
<h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><p><img src="/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/%E8%8E%B7%E5%8F%96%E9%94%81.png" alt="获取锁.png"></p>
<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p><img src="/2022/11/06/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/%E9%87%8A%E6%94%BE%E9%94%81.png" alt="释放锁.png"></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows安装Nginx</title>
    <url>/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/</url>
    <content><![CDATA[<h1 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h1><p>官网地址：<code>http://nginx.org/en/download.html</code><br><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/Nginx%E4%B8%8B%E8%BD%BD.png" alt="Nginx下载.png"></p>
<span id="more"></span>
<h1 id="解压Nginx"><a href="#解压Nginx" class="headerlink" title="解压Nginx"></a>解压Nginx</h1><p><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/%E8%A7%A3%E5%8E%8BNginx.png" alt="解压Nginx.png"></p>
<h1 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h1><h2 id="快捷启动"><a href="#快捷启动" class="headerlink" title="快捷启动"></a>快捷启动</h2><p>直接双击Nginx目录下的nginx.exe，双击后一个黑色的弹窗一闪而过，启动就完成了<br><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/Nginx%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8.png" alt="Nginx快捷启动.png"></p>
<h2 id="命令启动"><a href="#命令启动" class="headerlink" title="命令启动"></a>命令启动</h2><p>cmd窗口下，切换到Nginx安装目录，输入start nginx，回车启动<br><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/Nginx%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8.png" alt="Nginx命令启动.png"></p>
<h2 id="启动验证"><a href="#启动验证" class="headerlink" title="启动验证"></a>启动验证</h2><p>打开浏览器，输入<code>localhost</code>，回车，进入Nginx首页<br><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/Nginx%E9%A6%96%E9%A1%B5.png" alt="Nginx首页.png"></p>
<h1 id="关闭Nginx"><a href="#关闭Nginx" class="headerlink" title="关闭Nginx"></a>关闭Nginx</h1><p>cmd窗口下，切换到Nginx安装目录，输入以下命令，关闭Nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 快速停止nginx</span><br><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line">-- 完整有序地停止nginx</span><br><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>负载均衡</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper分布式锁应用——秒杀活动</title>
    <url>/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h1><p>淘宝双十一我们都知道，数以亿计的买家在同一时间去争抢有限数量的商品，也就是所谓的商品秒杀活动。面对如此高的并发，如果我们不采取一些措施，将会引发一系列问题，比如：商品超卖、单机锁的失效等。</p>
<h2 id="商品超卖"><a href="#商品超卖" class="headerlink" title="商品超卖"></a>商品超卖</h2><p>假设有100个用户同时去抢一个商品，并且全部下单成功，但是由于并发问题没有得到有效处理，导致实际库存只扣减了99个，也就是发生了1个商品的超卖。</p>
<h2 id="单机锁的失效"><a href="#单机锁的失效" class="headerlink" title="单机锁的失效"></a>单机锁的失效</h2><p>如果我们的服务是单实例的话，可以通过加单机锁来实现对并发问题的处理。这里的单机锁指的是JVM进程级别的锁，比如关键字<code>synchronized</code>、juc并发包下的工具类等等。但如果是分布式系统的话，服务通常是以多实例的姿态出现的，这时候单机锁将会失效。</p>
<span id="more"></span>
<h1 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h1><h2 id="单机环境搭建"><a href="#单机环境搭建" class="headerlink" title="单机环境搭建"></a>单机环境搭建</h2><p>这里我们就简单一点，直接用IDE启动一个SpringBoot项目，提供一个外部调用的REST接口代表商品下单即可，具体代码请参见<code>https://github.com/jyinjuly/zookeeper/tree/master/zookeeper-distributed-lock</code>。这里我们重点看一下Controller层接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.selectProduct(<span class="number">1L</span>);</span><br><span class="line">        log.info(<span class="string">&quot;当前库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            product.setNumber(product.getNumber()-<span class="number">1</span>);</span><br><span class="line">            productService.updateProduct(product);</span><br><span class="line">            log.info(<span class="string">&quot;出库成功，剩余库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口逻辑很简单，首先查询商品，如果商品还有库存，则去做扣减库存操作。</p>
<h2 id="复现商品超卖"><a href="#复现商品超卖" class="headerlink" title="复现商品超卖"></a>复现商品超卖</h2><h3 id="jmeter模拟并发请求"><a href="#jmeter模拟并发请求" class="headerlink" title="jmeter模拟并发请求"></a>jmeter模拟并发请求</h3><p>jmeter的安装这里就不做说明了，请各位读者小伙伴自行百度。我们只介绍本次模拟的相关参数，如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E7%BA%BF%E7%A8%8B%E7%BB%841.png" alt="线程组1.png"><br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/HTTP%E8%AF%B7%E6%B1%821.png" alt="HTTP请求1.png"></p>
<h3 id="请求结果分析"><a href="#请求结果分析" class="headerlink" title="请求结果分析"></a>请求结果分析</h3><p>首先，初始库存如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%9D%E5%A7%8B%E5%BA%93%E5%AD%98.png" alt="初始库存.png"><br>并发请求之后的库存如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E8%B6%85%E5%8D%96%E5%90%8E%E5%BA%93%E5%AD%98.png" alt="超卖后库存.png"><br>什么意思？客户下单成功了100个商品，实际库存却只扣减了3个！什么原因导致的呢？分析如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E8%B6%85%E5%8D%96%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90.png" alt="超卖原因分析.png"><br>究其原因是代码没有针对并发场景做处理导致的。</p>
<h2 id="单机锁解决商品超卖"><a href="#单机锁解决商品超卖" class="headerlink" title="单机锁解决商品超卖"></a>单机锁解决商品超卖</h2><p>针对以上单机环境的并发问题，可以通过加JVM锁处理。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/deduct&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 单机版加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (ProductController.class) &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.selectProduct(<span class="number">1L</span>);</span><br><span class="line">        log.info(<span class="string">&quot;当前库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            product.setNumber(product.getNumber()-<span class="number">1</span>);</span><br><span class="line">            productService.updateProduct(product);</span><br><span class="line">            log.info(<span class="string">&quot;出库成功，剩余库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，初始库存如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%9D%E5%A7%8B%E5%BA%93%E5%AD%98.png" alt="初始库存.png"><br>并发请求之后的库存如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%89%A9%E4%BD%99%E5%BA%93%E5%AD%98.png" alt="剩余库存.png"></p>
<h2 id="分布式环境搭建"><a href="#分布式环境搭建" class="headerlink" title="分布式环境搭建"></a>分布式环境搭建</h2><p>这里我们通过IDE并行启动两个服务实例，端口号分别为8080和8081。然后通过（本地）Nginx将请求反向代理到这两个实例，实现简单的分布式系统。</p>
<h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="Nginx反向代理.png"></p>
<h3 id="服务并行启动"><a href="#服务并行启动" class="headerlink" title="服务并行启动"></a>服务并行启动</h3><p>首先配置服务允许并行启动，如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%A1%8C%E5%90%AF%E5%8A%A8.png" alt="服务并行启动.png"><br>然后手动修改端口号，分别启动8080服务实例和8081服务实例。</p>
<h2 id="单机锁失效"><a href="#单机锁失效" class="headerlink" title="单机锁失效"></a>单机锁失效</h2><p>有了分布式环境，我们再去测试一下单机锁还能否解决商品超卖的问题，首先修改一下jmeter的HTTP请求，如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/HTTP%E8%AF%B7%E6%B1%822.png" alt="HTTP请求2.png"><br>然后模拟并发请求，结果如下，首先，初始库存：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%9D%E5%A7%8B%E5%BA%93%E5%AD%98.png" alt="初始库存.png"><br>并发请求之后的库存：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B6%85%E5%8D%96%E5%90%8E%E5%BA%93%E5%AD%98.png" alt="分布式超卖后库存.png"><br>结果显而易见，单机锁在分布式环境下失效了。</p>
<h1 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h1><p>分布式锁有很多种实现，比如Redis分布式锁、Zookeeper分布式锁等等，这里我们使用的是Zookeeper版本，而且还是Curator框架封装好的工具类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/deduct&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// zookeeper分布式锁</span></span><br><span class="line">    <span class="type">InterProcessMutex</span> <span class="variable">processMutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(curatorFramework, <span class="string">&quot;/product_1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        processMutex.acquire();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.selectProduct(<span class="number">1L</span>);</span><br><span class="line">        log.info(<span class="string">&quot;当前库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            product.setNumber(product.getNumber()-<span class="number">1</span>);</span><br><span class="line">            productService.updateProduct(product);</span><br><span class="line">            log.info(<span class="string">&quot;出库成功，剩余库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processMutex.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后模拟并发请求，结果如下，首先，初始库存：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%9D%E5%A7%8B%E5%BA%93%E5%AD%98.png" alt="初始库存.png"><br>并发请求之后的库存：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%89%A9%E4%BD%99%E5%BA%93%E5%AD%98.png" alt="剩余库存.png"><br>由此可见，使用分布式锁，分布式环境下的并发问题得以解决。</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper单机版安装</title>
    <url>/2022/10/13/Zookeeper%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h1><h2 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># java version &quot;1.8.0_271&quot;</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h2 id="下载并解压Zookeeper"><a href="#下载并解压Zookeeper" class="headerlink" title="下载并解压Zookeeper"></a>下载并解压Zookeeper</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载安装包</span><br><span class="line">wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper‐3.5.8/apache‐zookeeper‐3.5.8‐bin.tar.gz</span><br><span class="line"># 解压安装包</span><br><span class="line">tar ‐zxvf apache‐zookeeper‐3.5.8‐bin.tar.gz</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="备份配置文件（非必须）"><a href="#备份配置文件（非必须）" class="headerlink" title="备份配置文件（非必须）"></a>备份配置文件（非必须）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入配置文件目录</span></span><br><span class="line"><span class="built_in">cd</span> apache-zookeeper-3.5.8-bin/conf/</span><br><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line"><span class="built_in">cp</span> zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<h2 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入脚本文件目录</span></span><br><span class="line"><span class="built_in">cd</span> apache-zookeeper-3.5.8-bin/bin/</span><br><span class="line"><span class="comment"># 启动Zookeeper</span></span><br><span class="line">./zkServer.sh start ../conf/zoo.cfg</span><br><span class="line"><span class="comment"># 检测是否启动</span></span><br><span class="line">ps -ef | grep zookeeper</span><br></pre></td></tr></table></figure>
<h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><h2 id="终端方式连接"><a href="#终端方式连接" class="headerlink" title="终端方式连接"></a>终端方式连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入脚本文件目录</span></span><br><span class="line"><span class="built_in">cd</span> apache-zookeeper-3.5.8-bin/bin/</span><br><span class="line"><span class="comment"># 连接zookeeper</span></span><br><span class="line">./zkCli.sh -server 192.168.175.175:2181</span><br><span class="line"><span class="comment"># 查看所有节点</span></span><br><span class="line"><span class="built_in">ls</span> -R /</span><br></pre></td></tr></table></figure>
<h2 id="可视化工具（ZooInspector）连接"><a href="#可视化工具（ZooInspector）连接" class="headerlink" title="可视化工具（ZooInspector）连接"></a>可视化工具（ZooInspector）连接</h2><ul>
<li>下载工具：<a href="https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip">https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</a></li>
<li>解压，进入目录ZooInspector\build</li>
<li>创建zkClient.bat脚本文件，内容如下：<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">java -jar D:\ZooInspector\build\zookeeper-dev-ZooInspector.jar</span><br></pre></td></tr></table></figure></li>
<li>右键zkClient.bat文件，创建桌面快捷方式，然后修改一个自己喜欢的图标</li>
<li>双击快捷方式，打开可视化工具——ZooInspector，输入连接信息<br><img src="/2022/10/13/Zookeeper%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85/ZooInspector1.png" alt="ZooInspector1.png"></li>
<li>点击OK，连接成功<br><img src="/2022/10/13/Zookeeper%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85/ZooInspector2.png" alt="ZooInspector2.png"></li>
</ul>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>CentOS7</tag>
        <tag>客户端工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper特性——事件监听机制</title>
    <url>/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Zookeeper有两大特性——文件系统和事件监听机制，本篇介绍事件监听机制。</p>
<h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><p>Zookeeper中的事件类型有五种，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EventType</span> &#123;</span><br><span class="line">    None (-<span class="number">1</span>),</span><br><span class="line">    NodeCreated (<span class="number">1</span>),            <span class="comment">// 节点被创建时触发</span></span><br><span class="line">    NodeDeleted (<span class="number">2</span>),            <span class="comment">// 节点被删除时触发</span></span><br><span class="line">    NodeDataChanged (<span class="number">3</span>),        <span class="comment">// 节点的节点数据发生变化时触发</span></span><br><span class="line">    NodeChildrenChanged (<span class="number">4</span>),    <span class="comment">// 节点的子节点列表发生变化时触发</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.5.x之后新加的事件类型</span></span><br><span class="line">    DataWatchRemoved (<span class="number">5</span>),       <span class="comment">// 节点的监听被移除时触发</span></span><br><span class="line">    ChildWatchRemoved (<span class="number">6</span>);      <span class="comment">// 节点的子节点的监听被移除时触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="监听类型"><a href="#监听类型" class="headerlink" title="监听类型"></a>监听类型</h1><p>Zookeeper的监听类型总体分为两类，节点数据监听（NodeDataChanged）和节点目录监听（NodeCreated、NodeDeleted、NodeChildrenChanged）。</p>
<h2 id="节点数据监听"><a href="#节点数据监听" class="headerlink" title="节点数据监听"></a>节点数据监听</h2><p>节点数据监听只能针对单个节点设置。当节点的节点数据发生变化时，Zookeeper服务端会向所有注册了该节点数据监听的客户端发送一个NodeDataChanged事件。</p>
<blockquote>
<p>注意：节点数据并不单指节点存储的数据，还包括节点的元数据（状态信息）。</p>
</blockquote>
<h2 id="节点目录监听"><a href="#节点目录监听" class="headerlink" title="节点目录监听"></a>节点目录监听</h2><p>节点目录监听对应三种事件，所以我们也可以将节点目录监听分为三类：</p>
<ul>
<li>节点创建监听（NodeCreated）<blockquote>
<p>当一个节点被创建时，Zookeeper服务端会向所有注册了该节点创建监听的客户端发送一个NodeCreated事件。这里可能会有疑问，如何向一个不存在的节点注册监听？确实，Zookeeper原生客户端不支持这种操作，但是Zookeeper的Java客户端的一些API是支持的。</p>
</blockquote>
</li>
<li>节点删除监听（NodeDeleted）<blockquote>
<p>当一个节点被删除时，Zookeeper服务端会向所有注册了该节点删除监听的客户端发送一个NodeDeleted事件。</p>
</blockquote>
</li>
<li>子节点列表监听（NodeChildrenChanged）<blockquote>
<p>当一个节点发生子节点数量变化（新增、删除）时，Zookeeper服务端会向所有注册了该子节点列表监听的客户端发送一个NodeChildrenChanged事件。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>注意，节点目录监听不仅可以针对单个节点设置，还可以递归对节点及其所有下级节点进行设置。</p>
</blockquote>
<h1 id="监听操作（原生API）"><a href="#监听操作（原生API）" class="headerlink" title="监听操作（原生API）"></a>监听操作（原生API）</h1><h2 id="增加监听"><a href="#增加监听" class="headerlink" title="增加监听"></a>增加监听</h2><ul>
<li>增加节点数据监听<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get -w path</span><br><span class="line"><span class="built_in">stat</span> -w path</span><br></pre></td></tr></table></figure>
<img src="/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC.png" alt="节点数据监听.png"></li>
<li>增加节点目录监听<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -w path</span><br></pre></td></tr></table></figure>
<img src="/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/%E8%8A%82%E7%82%B9%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC1.png" alt="节点目录监听1.png"></li>
<li>递归增加节点目录监听<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -R -w path</span><br></pre></td></tr></table></figure>
<img src="/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/%E8%8A%82%E7%82%B9%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC2.png" alt="节点目录监听2.png"><br>这里执行了5条命令，每条命令都有其意义所在：<ul>
<li>ls -R -w &#x2F;：列出所有节点，并给所有节点增加节点目录监听。也就是说有且仅有这7个节点被注册了节点目录监听。</li>
<li>delete &#x2F;test&#x2F;a：触发了<code>/test/a</code>节点的NodeDeleted事件；触发了<code>/test</code>节点的NodeChildrenChanged事件。</li>
<li>delete &#x2F;test&#x2F;b：触发了<code>/test/b</code>节点的NodeDeleted事件；但是没有触发<code>/test</code>节点的NodeChildrenChanged事件，因为上一步已经触发过了。<strong>说到这里不得不提到Zookeeper监听机制一个很重要的特点，那就是所有的监听都是一次性的，一旦监听的事件被触发，监听将会被自动移除。</strong></li>
<li>create &#x2F;test&#x2F;c：新增一个节点，目的是为了测试新节点是否会被注册事件监听。</li>
<li>create &#x2F;test&#x2F;c&#x2F;1：没有触发<code>/test/c</code>节点的NodeChildrenChanged事件，证明新节点不会被注册事件监听。</li>
</ul>
</li>
</ul>
<h2 id="移除监听"><a href="#移除监听" class="headerlink" title="移除监听"></a>移除监听</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">removewatches path</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>事件监听机制</tag>
        <tag>一次性监听</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper特性——文件系统</title>
    <url>/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Zookeeper有两大特性——文件系统和事件监听机制，本篇介绍文件系统。</p>
<h1 id="文件系统简介"><a href="#文件系统简介" class="headerlink" title="文件系统简介"></a>文件系统简介</h1><p>Zookeeper维护一个类似文件系统的数据结构，如下图：<br><img src="/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Znode.png" alt="Znode.png"></p>
<span id="more"></span>
<p>其中每个目录项都被称为<strong>Znode（节点）</strong>，节点之下还可以增加子节点。每个节点拥有唯一路径path，并且均以根路径&#x2F;开头，节点还可以保存数据。</p>
<h1 id="节点Znode类型"><a href="#节点Znode类型" class="headerlink" title="节点Znode类型"></a>节点Znode类型</h1><h2 id="持久化节点"><a href="#持久化节点" class="headerlink" title="持久化节点"></a>持久化节点</h2><p>PERSISTENT（默认类型节点），客户端与Zookeeper断开连接后，节点依旧存在。只要不手动删除，这类节点将永远存在。</p>
<h2 id="持久化序号节点"><a href="#持久化序号节点" class="headerlink" title="持久化序号节点"></a>持久化序号节点</h2><p>PERSISTENT_SEQUENTIAL，与持久化节点一样，只是Zookeeper会自动给节点名称进行顺序编号。</p>
<blockquote>
<p>create -s</p>
</blockquote>
<h2 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h2><p>EPHEMERAL­，客户端与Zookeeper断开连接后，节点会被删除。</p>
<blockquote>
<p>create -e</p>
</blockquote>
<h2 id="临时序号节点"><a href="#临时序号节点" class="headerlink" title="临时序号节点"></a>临时序号节点</h2><p>EPHEMERAL_SEQUENTIAL，与临时节点一样，只是Zookeeper会自动给节点名称进行顺序编号。</p>
<blockquote>
<p>create -s -e</p>
</blockquote>
<h2 id="容器节点"><a href="#容器节点" class="headerlink" title="容器节点"></a>容器节点</h2><p>Container，3.5.3版本新增。容器节点的表现形式和持久化节点是一样的，区别在于Zookeeper服务端启动后，会有一个单独的线程去扫描所有的容器节点，当发现容器节点的子节点数量为0时，会自动删除该节点，除此之外和持久化节点没有区别。官方注释说是可以用在leader或者锁的场景中。</p>
<blockquote>
<p>create -c</p>
</blockquote>
<h2 id="TTL节点"><a href="#TTL节点" class="headerlink" title="TTL节点"></a>TTL节点</h2><p>带有存活时间的节点，简单来说就是当该节点下面没有子节点的话，超过了TTL指定时间后就会被自动删除，特性跟上面的容器节点很像，只是容器节点没有超时时间而已。默认禁用，只能通过系统配置<code>zookeeper.extendedTypesEnabled=true</code>开启，不稳定。</p>
<blockquote>
<p>create -t</p>
</blockquote>
<h1 id="节点Znode操作"><a href="#节点Znode操作" class="headerlink" title="节点Znode操作"></a>节点Znode操作</h1><h2 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create [‐s] [‐e] [‐c] [‐t ttl] path [data] [acl]</span><br></pre></td></tr></table></figure>
<ul>
<li>新增持久化序号节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create -s /node</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Created &#x2F;node0000000001</p>
</blockquote>
</li>
<li>新增临时节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create -e /node1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Created &#x2F;node1</p>
</blockquote>
</li>
<li>新增持久化节点，并添加数据<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /node2 node-data</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Created &#x2F;node2</p>
</blockquote>
</li>
</ul>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><ul>
<li>删除指定节点（不能包含子节点）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete path</span><br></pre></td></tr></table></figure></li>
<li>递归删除节点及其下级所有节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deleteall path</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查询（子）节点"><a href="#查询（子）节点" class="headerlink" title="查询（子）节点"></a>查询（子）节点</h2><ul>
<li>查询指定节点的子节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ls &#x2F;zookeeper<br>[config, quota]</p>
</blockquote>
</li>
<li>递归查询节点及其下级所有节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -R path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ls -R &#x2F;<br>&#x2F;<br>&#x2F;zookeeper<br>&#x2F;zookeeper&#x2F;config<br>&#x2F;zookeeper&#x2F;quota</p>
</blockquote>
</li>
</ul>
<h2 id="节点数据"><a href="#节点数据" class="headerlink" title="节点数据"></a>节点数据</h2><ul>
<li>设置（修改）节点数据<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> path node-data</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set &#x2F;zookeeper zookeeper</p>
</blockquote>
</li>
<li>获取节点数据<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get [-s] path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>get &#x2F;zookeeper<br>zookeeper<br>-s代表同时获取节点状态</p>
</blockquote>
</li>
</ul>
<h2 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>stat &#x2F;zookeeper<br>cZxid &#x3D; 0x0 —— 创建Znode的事务ID<br>ctime &#x3D; Thu Jan 01 08:00:00 CST 1970 —— Znode的创建时间<br>mZxid &#x3D; 0x34 —— 最后修改Znode的事务ID<br>mtime &#x3D; Mon Jun 20 22:32:50 CST 2022 —— Znode的最后修改时间<br>pZxid &#x3D; 0x0 —— 最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）<br>cversion &#x3D; -2 —— Znode的子节点结果集版本（子节点增加、删除都会影响这个版本）<br>dataVersion &#x3D; 2 —— Znode的数据版本<br>aclVersion &#x3D; 0 —— Znode的ACL版本<br>ephemeralOwner &#x3D; 0x0 —— 临时节点所有者的 session ID（零代表为非临时节点）。<br>dataLength &#x3D; 9 —— Znode数据字段的长度<br>numChildren &#x3D; 2 —— Znode子节点的数量</p>
</blockquote>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper的ACL权限控制</title>
    <url>/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Zookeeper的ACL权限控制，可以控制节点的读写操作，保证数据的安全性，Zookeeper的ACL权限设置分为3部分组成，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。最终组成一条例如“scheme:id:permission”格式的ACL请求信息。</p>
<h1 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h1><p>权限模式用来设置ZooKeeper服务器进行权限验证的方式。</p>
<h2 id="IP模式"><a href="#IP模式" class="headerlink" title="IP模式"></a>IP模式</h2><p>ZooKeeper可以针对一个IP或者一段IP地址授予某种权限。比如我们可以让一个IP地址为“ip:192.168.0.110”的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过“ip:192.168.0.1&#x2F;24”给一段IP地址的机器赋权。</p>
<blockquote>
<p>ip:192.168.175.175:rw</p>
</blockquote>
<span id="more"></span>
<h2 id="口令模式"><a href="#口令模式" class="headerlink" title="口令模式"></a>口令模式</h2><p>也可以理解为用户名密码的方式。在ZooKeeper中这种验证方式是Digest认证，而Digest这种认证方式首先在客户端传送“username:password”这种形式的权限表示符后，ZooKeeper服务端会对密码部分使用SHA-1和BASE64算法进行加密，以保证安全性。</p>
<h2 id="超级管理员模式"><a href="#超级管理员模式" class="headerlink" title="超级管理员模式"></a>超级管理员模式</h2><p>Super可以认为是一种特殊的Digest认证。具有Super权限的客户端可以对ZooKeepers上的任意数据节点进行任意操作。</p>
<h2 id="World模式"><a href="#World模式" class="headerlink" title="World模式"></a>World模式</h2><p>world模式表示授权所有用户，一般搭配anyone使用。</p>
<blockquote>
<p>world:anyone:cwrda</p>
</blockquote>
<h1 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h1><p>授权对象就是说我们要把权限赋予谁，而对应于不同的权限模式来说，授权对象有所不同。如下：</p>
<table>
<thead>
<tr>
<th>IP模式</th>
<th>口令模式</th>
<th>超级管理员模式</th>
<th>World模式</th>
</tr>
</thead>
<tbody><tr>
<td>ip地址&#x2F;ip地址列表（多个ip地址以逗号隔开）&#x2F;ip地址段</td>
<td>用户名</td>
<td>用户名</td>
<td>所有用户</td>
</tr>
</tbody></table>
<h1 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h1><h2 id="创建权限（c-create）"><a href="#创建权限（c-create）" class="headerlink" title="创建权限（c:create）"></a>创建权限（c:create）</h2><p>授予权限的对象可以在数据节点下<strong>创建子节点</strong></p>
<h2 id="删除权限（d-delete）"><a href="#删除权限（d-delete）" class="headerlink" title="删除权限（d:delete）"></a>删除权限（d:delete）</h2><p>授予权限的对象可以删除该节点的<strong>子节点</strong></p>
<h2 id="读取权限（r-read）"><a href="#读取权限（r-read）" class="headerlink" title="读取权限（r:read）"></a>读取权限（r:read）</h2><p>授予权限的对象可以读取该节点的节点数据以及子节点的列表信息</p>
<h2 id="更新权限（w-write）"><a href="#更新权限（w-write）" class="headerlink" title="更新权限（w:write）"></a>更新权限（w:write）</h2><p>授予权限的对象可以更新该节点的节点数据</p>
<h2 id="管理权限（a-admin）"><a href="#管理权限（a-admin）" class="headerlink" title="管理权限（a:admin）"></a>管理权限（a:admin）</h2><p>授予权限的对象可以对该节点体进行ACL权限设置</p>
<h1 id="权限操作（API）"><a href="#权限操作（API）" class="headerlink" title="权限操作（API）"></a>权限操作（API）</h1><h2 id="getAcl"><a href="#getAcl" class="headerlink" title="getAcl"></a>getAcl</h2><p>获取某个节点的acl权限信息</p>
<h2 id="setAcl"><a href="#setAcl" class="headerlink" title="setAcl"></a>setAcl</h2><p>设置某个节点的acl权限信息</p>
<h2 id="addauth"><a href="#addauth" class="headerlink" title="addauth"></a>addauth</h2><p>输入认证授权信息，相当于登录</p>
<h1 id="ACL实操"><a href="#ACL实操" class="headerlink" title="ACL实操"></a>ACL实操</h1><h2 id="IP模式-1"><a href="#IP模式-1" class="headerlink" title="IP模式"></a>IP模式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /test test-data ip:192.168.175.175:rw</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建节点，并授予ip地址为192.168.175.175的客户端该节点的读写权限</p>
</blockquote>
<h2 id="口令模式-1"><a href="#口令模式-1" class="headerlink" title="口令模式"></a>口令模式</h2><p>口令模式首先需要生成口令，有两种方式：</p>
<ul>
<li>通过命令直接生成<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> ‐n &lt;user&gt;:&lt;password&gt; | openssl dgst ‐binary ‐sha1 | openssl <span class="built_in">base64</span></span><br></pre></td></tr></table></figure></li>
<li>通过Java API生成<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGenerateDigest</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    log.info(DigestAuthenticationProvider.generateDigest(<span class="string">&quot;user1:password1&quot;</span>)); <span class="comment">// user1:XDkd2dsEuhc9ImU3q8pa8UOdtpI=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /test2 test2-data digest:user1:XDkd2dsEuhc9ImU3q8pa8UOdtpI=:rw</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建节点，并授予用户user1该节点的读写权限</p>
</blockquote>
<p><img src="/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E5%8F%A3%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="口令模式.png"></p>
<p>还有一种明文的口令模式，和digest用法一样，只需要在授权的时候把digest替换成auth即可。只不过需要在登录状态下才可以使用（并且只能授权当前登录用户）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /test3 test3-data auth:user1:password1</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E6%98%8E%E6%96%87%E5%8F%A3%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="明文口令模式.png"></p>
<h2 id="超级管理员模式-1"><a href="#超级管理员模式-1" class="headerlink" title="超级管理员模式"></a>超级管理员模式</h2><p>这是一种特殊的Digest模式， 在Super模式下超级管理员用户可以对Zookeeper上的任意节点进行任何操作。需要在启动时通过JVM系统参数开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dzookeeper.DigestAuthenticationProvider.superDigest=super:BBO7K8dPkoek/JxIHqXxM75QRpI=</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中super为超级管理员用户名，123456为超级管理员密码</p>
</blockquote>
<p>可以通过修改zkServer.sh来启用超级管理员：<br><img src="/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E8%B6%85%E7%BA%A7%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F.png" alt="超级管理员模式.png"></p>
<blockquote>
<p>可以通过<code>nohup</code>快捷搜索定位</p>
</blockquote>
<h2 id="跳过ACL认证"><a href="#跳过ACL认证" class="headerlink" title="跳过ACL认证"></a>跳过ACL认证</h2><p>可以通过系统参数<code>-Dzookeeper.skipACL=yes</code>进行配置，默认是no。可以配置为yes，则配置过的ACL将不再进行权限检测。<br><img src="/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E8%B7%B3%E8%BF%87%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81.png" alt="跳过权限认证.png"></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>ACL</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper集群搭建</title>
    <url>/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本篇以<strong>一主双从+一观察者</strong>为例搭建Zookeeper集群，旨在介绍集群中的一些概念以及特性。</p>
<h1 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h1><h2 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h2><p>领导者，也可以叫做主节点。主节点可以处理读写请求，集群中只能有一个主节点。</p>
<h2 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h2><p>跟随者，也可以叫做从节点。从节点只处理读请求，同时作为Leader节点的候选节点。即如果Leader宕机，Follower节点会参与到新的Leader选举中，有可能成为新的Leader节点。</p>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>观察者，只能处理读请求，并且不参与选举。通常是为了缓解整个集群的压力，提升集群的并发能力。</p>
<span id="more"></span>

<h1 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h1><p><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/Zookeeper%E9%9B%86%E7%BE%A4.png" alt="Zookeeper集群.png"></p>
<h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><h2 id="创建节点唯一ID"><a href="#创建节点唯一ID" class="headerlink" title="创建节点唯一ID"></a>创建节点唯一ID</h2><p>在Zookeeper的安装目录下，创建如下data目录结构：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E8%8A%82%E7%82%B9%E5%94%AF%E4%B8%80ID.png" alt="节点唯一ID.png"><br>其中的myid文件（文件名固定，不可随意起名）存储代表各个节点的唯一ID，如下：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E8%8A%82%E7%82%B9%E5%94%AF%E4%B8%80ID2.png" alt="节点唯一ID2.png"></p>
<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>在conf目录下，复制zoo_sample.cfg四份，分别命名：zk1.cfg、zk2.cfg、zk3.cfg、zk4.cfg，并进行如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- zk2、zk3、zk4</span><br><span class="line">dataDir=/usr/local/apache-zookeeper-3.5.8-bin/data/zk1</span><br><span class="line"></span><br><span class="line">-- 2182、2183、2184</span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line">server.1=192.168.175.175:2001:3001</span><br><span class="line">server.2=192.168.175.175:2002:3002</span><br><span class="line">server.3=192.168.175.175:2003:3003</span><br><span class="line">server.4=192.168.175.175:2004:3004:observer</span><br></pre></td></tr></table></figure>
<p>其中server.A&#x3D;B:C:D:E，各自含义如下：</p>
<ul>
<li>A：节点唯一ID</li>
<li>B：节点IP</li>
<li>C：集群通讯端口</li>
<li>D：集群选举端口</li>
<li>E：集群角色，默认是participant，即参与者，也就是参与过半机制的角色。另一个是observer，观察者，不参与过半机制。</li>
</ul>
<blockquote>
<p>过半机制有两个场景，第一是选举，第二是事务请求过半提交。</p>
</blockquote>
<h2 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h2><p>集群的启动没有什么特殊之处，就是依次启动各个节点。<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8.png" alt="集群启动.png"><br>然后查看一下集群状态：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81.png" alt="集群状态.png"><br>可以看到：主节点为zk2，从节点为zk1、zk3，观察者如配置为zk4。</p>
<h1 id="集群动态配置"><a href="#集群动态配置" class="headerlink" title="集群动态配置"></a>集群动态配置</h1><p>Zookeeper 3.5.0 以前，Zookeeper集群角色要发生改变的话，只能通过停掉所有的Zookeeper服务，修改集群配置，重启服务来完成，这样集群服务将有一段不可用的状态，为了应对高可用需求，Zookeeper 3.5.0 提供了支持动态扩容&#x2F;缩容的新特性。但是通过客户端API可以变更服务端集群状态是件很危险的事情，所以在zookeeper 3.5.3 版本要用动态配置，需要开启超级管理员身份验证模式 ACLs。如果是在一个安全的环境也可以通过配置系统参数<code>-Dzookeeper.skipACL=yes</code>来避免配置维护acl权限配置。下面我们就承接上文的集群架构，来看看如何进行集群的动态配置。</p>
<h2 id="权限处理"><a href="#权限处理" class="headerlink" title="权限处理"></a>权限处理</h2><p>可以通过<strong>添加超级管理员</strong>或者<strong>跳过权限认证</strong></p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改所有集群节点的配置文件（zk1.cfg, zk2.cfg, zk3.cfg, zk4.cfg），如下：</p>
<ul>
<li>移除clientPort配置</li>
<li>移除集群server.x配置</li>
<li>添加reconfigEnabled配置，设置为true开启动态配置</li>
<li>添加dynamicConfigFile配置，指定动态配置文件的位置</li>
</ul>
<h2 id="添加动态配置文件"><a href="#添加动态配置文件" class="headerlink" title="添加动态配置文件"></a>添加动态配置文件</h2><p>约定俗成，文件以.dynamic结尾，如下：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE.png" alt="动态配置.png"><br>文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server.1=192.168.175.175:2001:3001:participant;192.168.175.175:2181</span><br><span class="line">server.2=192.168.175.175:2002:3002:participant;192.168.175.175:2182</span><br><span class="line">server.3=192.168.175.175:2003:3003:participant;192.168.175.175:2183</span><br><span class="line">server.4=192.168.175.175:2004:3004:observer;192.168.175.175:2184</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在原来集群配置<code>server.A=B:C:D:E</code>的基础上加了一个F，变成了<code>server.A=B:C:D:E;F</code>，F代表服务ip:端口，<strong>注意E和F以分号隔开</strong></p>
</blockquote>
<h2 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h2><p>依次启动所有节点，连接任意一台服务进行操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动节点</span></span><br><span class="line">./bin/zkServer.sh start conf/zk1.cfg</span><br><span class="line">./bin/zkServer.sh start conf/zk2.cfg</span><br><span class="line">./bin/zkServer.sh start conf/zk3.cfg</span><br><span class="line">./bin/zkServer.sh start conf/zk4.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点状态</span></span><br><span class="line">./bin/zkServer.sh status conf/zk1.cfg</span><br><span class="line">./bin/zkServer.sh status conf/zk2.cfg</span><br><span class="line">./bin/zkServer.sh status conf/zk3.cfg</span><br><span class="line">./bin/zkServer.sh status conf/zk4.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要修改集群状态，需要超级管理员登录（或者跳过授权）</span></span><br><span class="line">addauth digest super:123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除id为3的机器</span></span><br><span class="line">reconfig -remove 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加对应机器</span></span><br><span class="line">reconfig -add server.3=192.168.175.175:2003:3003:participant;192.168.175.175:2183</span><br></pre></td></tr></table></figure>
<p>可以看到该过程集群配置变化如下：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E9%9B%86%E7%BE%A4%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE.png" alt="集群动态配置.png"></p>
<blockquote>
<p>如果要变更或者添加新的服务，需要满足以下几点：</p>
</blockquote>
<ul>
<li>新服务必须是动态配置节点（配置文件要符合要求）</li>
<li>要将新服务添加到配置文件zk1.cfg.dynamic（注意并不是zk1.cfg.dynamic.xxx）中</li>
<li>新服务要处于启动状态</li>
<li>连接任意一个集群客户端，执行<code>reconfig -add</code>操作</li>
<li>保证服务列表中participant角色能够形成集群（过半机制）</li>
</ul>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>集群</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程状态</title>
    <url>/2022/11/20/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h1 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h1><p>java线程有六种状态，在Thread类中有所体现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NEW</span><br></pre></td></tr></table></figure>
<p>新创建并且还未启动的线程，状态为NEW。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：NEW</p>
</blockquote>
<h2 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment"> * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment"> * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment"> * such as processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure>
<p>线程调用<code>start()</code>方法，进入可运行状态——RUNNABLE。RUNNABLE状态的线程在java虚拟机中已经开始执行，但是它可能还在等待来自操作系统的资源，比如处理器。为了便于理解，我们“擅自”将RUNNABLE状态拆分成两个阶段：</p>
<ol>
<li>READY——就绪状态，已经在java虚拟机中执行，但是并未实际执行任务，相当于空转<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadyThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;线程开始执行&quot;</span>));</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：RUNNABLE<br>线程开始执行</p>
</blockquote>
</li>
<li>RUNNING——执行中状态，获取了CPU时间片，真正在执行任务了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunningThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;线程状态：&quot;</span> + Thread.currentThread().getState())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：RUNNABLE</p>
</blockquote>
</li>
</ol>
<h2 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment"> * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment"> * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>阻塞线程的状态为BLOCKED。此状态下的线程正在等待一个监视器锁，目的是为了：</p>
<ol>
<li>能进入一个同步块或者同步方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 监视器锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">BlockedThread</span> <span class="variable">blockedThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockedThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(blockedThread::test);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(blockedThread::test);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 保证线程t1先拿到监视器锁，进入同步块</span></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程t2状态：&quot;</span> + t2.getState()); <span class="comment">// 线程t2正在等待获取监视器锁，以进入同步块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程t2状态：BLOCKED</p>
</blockquote>
</li>
<li>能（在监视器锁调用<code>Object#wait()</code>方法之后）重新进入一个同步块或者同步方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waiting2BlockedThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 监视器锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                obj.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Waiting2BlockedThread</span> <span class="variable">waiting2BlockedThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waiting2BlockedThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(waiting2BlockedThread::test);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(waiting2BlockedThread::test);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 保证线程t1先拿到监视器锁，进入同步块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程t1状态：&quot;</span> + t1.getState()); <span class="comment">// 监视器锁调用Object#wait()方法，当前锁持有线程t1释放锁并置为等待状态</span></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 保证线程t2进入同步块，监视器锁调用Object#notify()方法，将线程t1唤醒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程t1状态：&quot;</span> + t1.getState()); <span class="comment">// 唤醒之后的线程t1首先进入RUNNABLE状态去尝试获取监视器锁，发现锁被线程t2持有，于是又变为阻塞状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程t1状态：WAITING<br>线程t1状态：BLOCKED</p>
</blockquote>
</li>
</ol>
<h2 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"> * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"> * perform a particular action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment"> * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>等待线程的状态为WAITING。等待线程等待另一个线程去执行某一个特定的操作，以此将自己唤醒。当以下方法被执行时，线程将进入等待状态：</p>
<ol>
<li>Object#wait()：在线程t1中调用了监视器锁对象的wait()方法，线程t1将进入等待状态。等待另一个线程t2去调用相同的监视器锁对象的notify()&#x2F;nofityAll()方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wait2Waiting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 监视器锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait(); <span class="comment">// 线程进入等待状态</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                obj.notify(); <span class="comment">// 等待线程被唤醒</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Wait2Waiting</span> <span class="variable">wait2Waiting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wait2Waiting</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(wait2Waiting::test);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(wait2Waiting::test);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程t1状态：&quot;</span> + t1.getState());</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程t1状态：&quot;</span> + t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程t1状态：WAITING<br>线程t1状态：BLOCKED</p>
</blockquote>
</li>
<li>Thread#join()：在线程t2中调用了线程t1的join()方法，那么线程t2将进入等待状态，直到线程t1死亡。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Join2Waiting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join(); <span class="comment">// 线程t2进入等待状态，直到线程t1死亡</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123; &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程t2状态：&quot;</span> + t2.getState());</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>); <span class="comment">// 保证线程t1已经死亡，线程t2被唤醒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程t2状态：&quot;</span> + t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程t2状态：WAITING<br>线程t2状态：RUNNABLE</p>
</blockquote>
</li>
<li>LockSupport#park()：如果当前线程未被颁发过“许可证”，那么将会进入等待状态。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">park2Waiting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(LockSupport::park);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"> * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"> * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>限时等待线程的状态为TIMED_WAITING。限时等待状态的线程当超过等待时间时会自动唤醒，也可以像等待线程一样，通过等待另一个线程执行某一个操作将自己唤醒。当以下方法被执行时，线程将进入限时等待状态：</p>
<ol>
<li>Thread.sleep：当前线程睡眠指定时间。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sleep2TimedWaiting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>); <span class="comment">// 保证已经超过等待时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：TIMED_WAITING<br>线程状态：RUNNABLE</p>
</blockquote>
</li>
<li>Object#wait(long)：与Object#wait()类似，等待其他线程调用nofity()&#x2F;notifyAll()方法，或者等待超时自动唤醒。</li>
<li>Thread#join(long)：与Thread#join()类似，等待其他线程死亡，或者等待超时自动唤醒。</li>
<li>LockSupport.parkNanos(long)：与LockSupport.park()类似，传参为纳秒，代表最多等待的时长。</li>
<li>LockSupport.parkUntil(long)：与LockSupport.park()类似，传参为时间戳，代表最多等待到某时刻为止。</li>
</ol>
<h2 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment"> * The thread has completed execution.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>当线程执行完任务之后，就会变为终止状态——TERMINATED。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminatedThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;线程执行完毕！&quot;</span>));</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程执行完毕！<br>线程状态：TERMINATED</p>
</blockquote>
<h1 id="Java线程状态切换图"><a href="#Java线程状态切换图" class="headerlink" title="Java线程状态切换图"></a>Java线程状态切换图</h1><p><img src="/2022/11/20/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E5%9B%BE.png" alt="线程状态切换图.png"></p>
<h1 id="阻塞和等待的区别"><a href="#阻塞和等待的区别" class="headerlink" title="阻塞和等待的区别"></a>阻塞和等待的区别</h1><p>我们在讨论“阻塞”和“等待”的区别之前，有必要先说明一下：这里的“阻塞”是狭义上的阻塞，特指Java中的<code>java.lang.Thread.State#BLOCKED</code>，即由于争抢锁失败而的进入的线程状态。<strong>那什么是广义上的“阻塞”呢？一般来讲，线程阻塞泛指由于某些原因而导致线程暂停执行的现象，此时的线程不会被分配CPU时间片。如此说来，广义上的“阻塞”实际上就包括了Java线程的“阻塞”状态和“等待”状态了。并且，通常大家在讨论并发时所说的线程阻塞，也指的是广义上的“阻塞”。</strong>我们这里讨论的“阻塞”和“等待”的区别，指的是Java中的<code>java.lang.Thread.State#BLOCKED</code>和<code>java.lang.Thread.State#WAITING</code>，两者区别如下：</p>
<ul>
<li>线程进入阻塞状态是被动的，而线程进入等待状态是主动的<blockquote>
<p>主动等待：当前线程中一定是主动调用了某个方法才会进入等待状态<br>被动阻塞：线程争抢锁失败之后被动进入阻塞状态</p>
</blockquote>
</li>
</ul>
<p>两者相同点如下：</p>
<ul>
<li>都会暂停线程的执行，线程本身不会占用CPU时间片</li>
</ul>
<h1 id="线程状态相关API"><a href="#线程状态相关API" class="headerlink" title="线程状态相关API"></a>线程状态相关API</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ul>
<li>Object.wait()</li>
<li>Object.wait(long)</li>
<li>Object.notify()</li>
<li>Object.nofityAll()</li>
</ul>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><ul>
<li>Thread.start()</li>
<li>Thread.yield()</li>
<li>Thread.join()</li>
<li>Thread.join(long)</li>
<li>Thread.sleep(long)</li>
</ul>
<h2 id="LockSupport类"><a href="#LockSupport类" class="headerlink" title="LockSupport类"></a>LockSupport类</h2><ul>
<li>LockSupport.park()</li>
<li>LockSupport.parkNanos(long)</li>
<li>LockSupport.parkUntil(long)</li>
<li>LockSupport.unpark(Thread)</li>
</ul>
<h1 id="Java线程中断"><a href="#Java线程中断" class="headerlink" title="Java线程中断"></a>Java线程中断</h1><p>线程中断并不是线程的一种状态，而是线程的一个标志。</p>
<h2 id="中断相关API"><a href="#中断相关API" class="headerlink" title="中断相关API"></a>中断相关API</h2><ul>
<li>public boolean isInterrupted() —— 查看线程的中断标志</li>
<li>public void thread.interrupt() —— 设置线程中断标志</li>
<li>public static boolean interrupted() —— 查看并重置线程的中断标志</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程是否中断：&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;重置线程中断标志：&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;重置后......线程是否中断：&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程是否中断：&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;重置线程中断标志：&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;重置后......线程是否中断：&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当前线程是否中断：false<br>重置线程中断标志：false<br>重置后……线程是否中断：false</p>
<hr>
<p>当前线程是否中断：true<br>重置线程中断标志：true<br>重置后……线程是否中断：false</p>
</blockquote>
<h2 id="不同状态对中断的反应"><a href="#不同状态对中断的反应" class="headerlink" title="不同状态对中断的反应"></a>不同状态对中断的反应</h2><p>当线程处于不同的状态时，对调用interrupt()方法的反应是不同的。</p>
<h3 id="NEW——无反应"><a href="#NEW——无反应" class="headerlink" title="NEW——无反应"></a>NEW——无反应</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">New2Interrupted</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：NEW<br>是否中断：false<br>线程状态：NEW<br>是否中断：false</p>
</blockquote>
<h3 id="TERMINATED——无反应"><a href="#TERMINATED——无反应" class="headerlink" title="TERMINATED——无反应"></a>TERMINATED——无反应</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Terminated2Interrupted</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：TERMINATED<br>是否中断：false<br>线程状态：TERMINATED<br>是否中断：false</p>
</blockquote>
<h3 id="RUNNABLE——标志置位true"><a href="#RUNNABLE——标志置位true" class="headerlink" title="RUNNABLE——标志置位true"></a>RUNNABLE——标志置位true</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runnable2Interrupted</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 我们可以根据中断标志做一些事情</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程已中断......&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断；&quot;</span> + thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断；&quot;</span> + thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：RUNNABLE<br>是否中断；false<br>线程状态：RUNNABLE<br>是否中断；true<br>线程已中断……</p>
</blockquote>
<h3 id="BLOCKED——标志置位true"><a href="#BLOCKED——标志置位true" class="headerlink" title="BLOCKED——标志置位true"></a>BLOCKED——标志置位true</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blocked2Interrupted</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Blocked2Interrupted</span> <span class="variable">blocked2Interrupted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blocked2Interrupted</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(blocked2Interrupted::test);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(blocked2Interrupted::test);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + t2.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + t2.isInterrupted());</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + t2.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + t2.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：BLOCKED<br>是否中断：false<br>线程状态：BLOCKED<br>是否中断：true</p>
</blockquote>
<h3 id="WAITING——抛异常（LockSupport除外）"><a href="#WAITING——抛异常（LockSupport除外）" class="headerlink" title="WAITING——抛异常（LockSupport除外）"></a>WAITING——抛异常（LockSupport除外）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waiting2Interrupted</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> LockSupport#park()&#125;方法导致的waiting状态时，执行中断</span></span><br><span class="line"><span class="comment">         * 中断标志位变为true，但是线程的运行状态不受影响。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(LockSupport::park);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + thread.isInterrupted());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：WAITING<br>是否中断：false<br>线程状态：WAITING<br>是否中断：true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waiting2Interrupted</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait()&#125;方法导致的waiting状态时，执行中断会抛出异常。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Waiting2Interrupted</span> <span class="variable">waiting2Interrupted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waiting2Interrupted</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(waiting2Interrupted::test);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：WAITING<br>是否中断：false<br>java.lang.InterruptedException<br>  at java.lang.Object.wait(Native Method)<br>  at java.lang.Object.wait(Object.java:502)<br>  at thread.interrupt.Waiting2Interrupted.test(Waiting2Interrupted.java:17)<br>  at java.lang.Thread.run(Thread.java:748)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waiting2Interrupted</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Thread#join()&#125;方法导致的waiting状态时，执行中断会抛出异常。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + t2.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + t2.isInterrupted());</span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：WAITING<br>是否中断：false<br>java.lang.InterruptedException<br>    at java.lang.Object.wait(Native Method)<br>    at java.lang.Thread.join(Thread.java:1252)<br>    at java.lang.Thread.join(Thread.java:1326)<br>    at thread.interrupt.Waiting2Interrupted.lambda$main$1(Waiting2Interrupted.java:60)<br>    at java.lang.Thread.run(Thread.java:748)</p>
</blockquote>
<h3 id="TIMED-WAITING——抛异常（LockSupport除外）"><a href="#TIMED-WAITING——抛异常（LockSupport除外）" class="headerlink" title="TIMED_WAITING——抛异常（LockSupport除外）"></a>TIMED_WAITING——抛异常（LockSupport除外）</h3><p><code>LockSupport.parkNanos(long)</code>和<code>LockSupport.parkUntil(long)</code>导致的TIMED_WAITING状态类似于<code>LockSupport.park()</code>导致的WAITING状态，调用<code>interrupt()</code>方法会将线程的标志置为true。而<code>Thread.sleep(long)</code>、<code>Object.wait(long)</code>及<code>Thread.join(long)</code>导致的TIMED_WAITING状态类似于<code>Object.wait()</code>及<code>Thread.join()</code>导致的WAITING状态，调用<code>interrupt()</code>方法会抛异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Timed_Waiting2Interrupted</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Thread#sleep(long)&#125;方法导致的timed_waiting状态时，执行中断会抛出异常。</span></span><br><span class="line"><span class="comment">         * 同理&#123;<span class="doctag">@link</span> Object#wait(long)&#125;与&#123;<span class="doctag">@link</span> Thread#join(long)&#125;结果一样。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否中断：&quot;</span> + thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> LockSupport#parkUntil(long)&#125;方法导致的waiting状态时，执行中断</span></span><br><span class="line"><span class="comment">         * 中断标志位变为true，但是线程的运行状态不受影响。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(() -&gt; LockSupport.parkUntil(System.currentTimeMillis() + 10000));</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line"><span class="comment">//        Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;线程状态：&quot; + thread.getState());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;是否中断：&quot; + thread.isInterrupted());</span></span><br><span class="line"><span class="comment">//        thread.interrupt();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;线程状态：&quot; + thread.getState());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;是否中断：&quot; + thread.isInterrupted());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> LockSupport#parkNanos(long)&#125;方法导致的waiting状态时，执行中断</span></span><br><span class="line"><span class="comment">         * 中断标志位变为true，但是线程的运行状态不受影响。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(() -&gt; LockSupport.parkNanos(10000000000L));</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line"><span class="comment">//        Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;线程状态：&quot; + thread.getState());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;是否中断：&quot; + thread.isInterrupted());</span></span><br><span class="line"><span class="comment">//        thread.interrupt();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;线程状态：&quot; + thread.getState());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;是否中断：&quot; + thread.isInterrupted());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程状态：TIMED_WAITING<br>是否中断：false<br>java.lang.InterruptedException: sleep interrupted<br>    at java.lang.Thread.sleep(Native Method)<br>    at thread.interrupt.Timed_Waiting2Interrupted.lambda$main$0(Timed_Waiting2Interrupted.java:22)<br>    at java.lang.Thread.run(Thread.java:748)</p>
</blockquote>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Java线程</tag>
      </tags>
  </entry>
</search>
