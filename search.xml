<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS安装Docker</title>
    <url>/2022/10/16/CentOS%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h1 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h1><p>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><h2 id="安装前置依赖"><a href="#安装前置依赖" class="headerlink" title="安装前置依赖"></a>安装前置依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
<h2 id="设置-Docker-仓库"><a href="#设置-Docker-仓库" class="headerlink" title="设置 Docker 仓库"></a>设置 Docker 仓库</h2><h3 id="官方源"><a href="#官方源" class="headerlink" title="官方源"></a>官方源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="阿里云源"><a href="#阿里云源" class="headerlink" title="阿里云源"></a>阿里云源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="清华大学源"><a href="#清华大学源" class="headerlink" title="清华大学源"></a>清华大学源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h2 id="执行-Docker-安装"><a href="#执行-Docker-安装" class="headerlink" title="执行 Docker 安装"></a>执行 Docker 安装</h2><h3 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>
<h3 id="指定版本"><a href="#指定版本" class="headerlink" title="指定版本"></a>指定版本</h3><p>要安装特定版本的 Docker，请在存储库中列出可用版本，然后选择并安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/16/CentOS%E5%AE%89%E8%A3%85Docker/Docker%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9.png" alt="Docker版本选择.png"><br>通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>
<h1 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h1 id="验证启动"><a href="#验证启动" class="headerlink" title="验证启动"></a>验证启动</h1><p>通过运行 hello-world 镜像来验证是否启动成功（首次运行可能需要先拉取镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/16/CentOS%E5%AE%89%E8%A3%85Docker/Docker%E5%90%AF%E5%8A%A8%E9%AA%8C%E8%AF%81.png" alt="Docker启动验证.png"></p>
<h1 id="关闭-Docker"><a href="#关闭-Docker" class="headerlink" title="关闭 Docker"></a>关闭 Docker</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/16/CentOS%E5%AE%89%E8%A3%85Docker/Docker%E8%87%AA%E5%8A%A8%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6.png" alt="Docker自动唤醒机制.png"></p>
<h1 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h1><p>删除安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker-ce</span><br></pre></td></tr></table></figure>
<p>删除镜像、容器、配置文件等内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装MySQL</title>
    <url>/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/</url>
    <content><![CDATA[<h1 id="查看可用版本"><a href="#查看可用版本" class="headerlink" title="查看可用版本"></a>查看可用版本</h1><p>访问 MySQL 镜像库地址：<a href="https://hub.docker.com/_/mysql?tab=tags">https://hub.docker.com/_/mysql?tab=tags</a></p>
<span id="more"></span>

<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/%E6%9F%A5%E8%AF%A2%E5%8F%AF%E7%94%A8%E9%95%9C%E5%83%8F.png" alt="查询可用镜像.png"></p>
<h1 id="拉取MySQL镜像"><a href="#拉取MySQL镜像" class="headerlink" title="拉取MySQL镜像"></a>拉取MySQL镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull mysql:8.0.31</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/%E6%8B%89%E5%8F%96MySQL%E9%95%9C%E5%83%8F.png" alt="拉取MySQL镜像.png"></p>
<h1 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" alt="查看本地镜像.png"></p>
<h1 id="运行MySQL容器"><a href="#运行MySQL容器" class="headerlink" title="运行MySQL容器"></a>运行MySQL容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0.31</span><br></pre></td></tr></table></figure>
<ul>
<li>-p 3306:3306：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 <code>宿主机ip:3306</code> 访问到 MySQL 的服务</li>
<li>MYSQL_ROOT_PASSWORD&#x3D;123456：设置MySQL服务root用户的密码</li>
</ul>
<h1 id="验证启动成功"><a href="#验证启动成功" class="headerlink" title="验证启动成功"></a>验证启动成功</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85MySQL/%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8.png" alt="验证启动.png"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器使用</title>
    <url>/2022/10/23/Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull mysql:8.0.31</span><br></pre></td></tr></table></figure>

<h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.31</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="查询运行容器"><a href="#查询运行容器" class="headerlink" title="查询运行容器"></a>查询运行容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/%E6%9F%A5%E8%AF%A2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8.png" alt="查询运行容器.png"></p>
<ul>
<li>CONTAINER ID: 容器id</li>
<li>IMAGE: 镜像</li>
<li>NAMES: 容器名称</li>
</ul>
<h1 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stop e60de6d38a35</span><br></pre></td></tr></table></figure>

<h1 id="查询所有容器"><a href="#查询所有容器" class="headerlink" title="查询所有容器"></a>查询所有容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8.png" alt="查询所有容器.png"></p>
<h1 id="启动停止容器"><a href="#启动停止容器" class="headerlink" title="启动停止容器"></a>启动停止容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker start e60de6d38a35 </span><br></pre></td></tr></table></figure>

<h1 id="重启运行容器"><a href="#重启运行容器" class="headerlink" title="重启运行容器"></a>重启运行容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker restart e60de6d38a35 </span><br></pre></td></tr></table></figure>

<h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it e60de6d38a35 /bin/bash</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用exec进入容器，如果从这个容器退出，容器不会停止；也可以使用<code>docker attach e60de6d38a35</code>进入容器，但是如果从这个容器退出，会导致容器的停止。因此推荐使用exec。</p>
</blockquote>
<h1 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span> -f e60de6d38a35</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Zookeeper</title>
    <url>/2022/10/23/Docker%E5%AE%89%E8%A3%85Zookeeper/</url>
    <content><![CDATA[<h1 id="查看可用版本"><a href="#查看可用版本" class="headerlink" title="查看可用版本"></a>查看可用版本</h1><p>访问 Zookeeper 镜像库地址：<a href="https://hub.docker.com/_/zookeeper/tags">https://hub.docker.com/_/zookeeper/tags</a></p>
<span id="more"></span>

<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85Zookeeper/%E6%9F%A5%E8%AF%A2%E5%8F%AF%E7%94%A8%E9%95%9C%E5%83%8F.png" alt="查询可用镜像.png"></p>
<h1 id="拉取Zookeeper镜像"><a href="#拉取Zookeeper镜像" class="headerlink" title="拉取Zookeeper镜像"></a>拉取Zookeeper镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull zookeeper:3.5.8</span><br></pre></td></tr></table></figure>

<h1 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85Zookeeper/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" alt="查看本地镜像.png"></p>
<h1 id="运行Zookeeper容器"><a href="#运行Zookeeper容器" class="headerlink" title="运行Zookeeper容器"></a>运行Zookeeper容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name zookeeper -p 2181:2181 zookeeper:3.5.8</span><br></pre></td></tr></table></figure>
<ul>
<li>-p 2181:2181：映射容器服务的 2181 端口到宿主机的 2181 端口，外部主机可以直接通过 <code>宿主机ip:2181</code> 访问到 Zookeeper 的服务</li>
</ul>
<h1 id="验证启动成功"><a href="#验证启动成功" class="headerlink" title="验证启动成功"></a>验证启动成功</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E5%AE%89%E8%A3%85Zookeeper/%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8.png" alt="验证启动.png"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像使用</title>
    <url>/2022/10/23/Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" alt="查看本地镜像.png"></p>
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小<span id="more"></span></li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:15.10 /bin/bash</span><br></pre></td></tr></table></figure>
<ul>
<li>-i: 交互式操作。</li>
<li>-t: 终端。</li>
<li>ubuntu:15.10: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</li>
<li>&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</li>
</ul>
<p><strong>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像（而如果你本地没有最新的镜像，则会自动拉取）。</strong></p>
<h1 id="查找远程镜像"><a href="#查找远程镜像" class="headerlink" title="查找远程镜像"></a>查找远程镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search mysql</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/23/Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F.png" alt="查找镜像.png"></p>
<ul>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否 docker 官方发布</li>
<li>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li>AUTOMATED: 自动构建。</li>
</ul>
<h1 id="拉取远程镜像"><a href="#拉取远程镜像" class="headerlink" title="拉取远程镜像"></a>拉取远程镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull mysql:8.0.31</span><br></pre></td></tr></table></figure>

<h1 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rmi mysql:8.0.31s</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之客户端连接那些事</title>
    <url>/2022/10/23/MySQL%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="Root用户忘记密码"><a href="#Root用户忘记密码" class="headerlink" title="Root用户忘记密码"></a>Root用户忘记密码</h1><ol>
<li>配置文件——my.cnf中添加：skip-grant-tables，保存退出；</li>
<li>重启mysql服务使配置文件生效：service mysqld restart；</li>
<li>mysql -uroot -p回车登录；</li>
<li>使用mysql数据库：use mysql；<span id="more"></span></li>
<li>将root密码置为空：update user set authentication_string &#x3D; ‘’ where user &#x3D; ‘root’;</li>
<li>my.cnf中删掉步骤1的语句——skip-grant-tables，重启mysql服务；</li>
<li>登录mysql，修改root用户密码：ALTER USER ‘root‘@’localhost’ IDENTIFIED with mysql_native_password BY ‘${password}’;</li>
</ol>
<h1 id="MySQL-8-连接失败：caching-sha2…"><a href="#MySQL-8-连接失败：caching-sha2…" class="headerlink" title="MySQL 8 连接失败：caching sha2…"></a>MySQL 8 连接失败：caching sha2…</h1><p>MySQL 8 之前的版本使用的密码加密规则是mysql_native_password，但是在mysql 8 则是caching_sha2_password，解决办法如下：</p>
<h2 id="修改加密规则"><a href="#修改加密规则" class="headerlink" title="修改加密规则"></a>修改加密规则</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL-8-客户端无法使用root用户登录"><a href="#MySQL-8-客户端无法使用root用户登录" class="headerlink" title="MySQL 8 客户端无法使用root用户登录"></a>MySQL 8 客户端无法使用root用户登录</h1><h2 id="root登录mysql"><a href="#root登录mysql" class="headerlink" title="root登录mysql"></a>root登录mysql</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br></pre></td></tr></table></figure>

<h2 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;liteng&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;liteng&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>客户端连接</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows安装Nginx</title>
    <url>/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/</url>
    <content><![CDATA[<h1 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h1><p>官网地址：<code>http://nginx.org/en/download.html</code><br><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/Nginx%E4%B8%8B%E8%BD%BD.png" alt="Nginx下载.png"></p>
<span id="more"></span>
<h1 id="解压Nginx"><a href="#解压Nginx" class="headerlink" title="解压Nginx"></a>解压Nginx</h1><p><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/%E8%A7%A3%E5%8E%8BNginx.png" alt="解压Nginx.png"></p>
<h1 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h1><h2 id="快捷启动"><a href="#快捷启动" class="headerlink" title="快捷启动"></a>快捷启动</h2><p>直接双击Nginx目录下的nginx.exe，双击后一个黑色的弹窗一闪而过，启动就完成了<br><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/Nginx%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8.png" alt="Nginx快捷启动.png"></p>
<h2 id="命令启动"><a href="#命令启动" class="headerlink" title="命令启动"></a>命令启动</h2><p>cmd窗口下，切换到Nginx安装目录，输入start nginx，回车启动<br><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/Nginx%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8.png" alt="Nginx命令启动.png"></p>
<h2 id="启动验证"><a href="#启动验证" class="headerlink" title="启动验证"></a>启动验证</h2><p>打开浏览器，输入<code>localhost</code>，回车，进入Nginx首页<br><img src="/2022/10/16/Windows%E5%AE%89%E8%A3%85Nginx/Nginx%E9%A6%96%E9%A1%B5.png" alt="Nginx首页.png"></p>
<h1 id="关闭Nginx"><a href="#关闭Nginx" class="headerlink" title="关闭Nginx"></a>关闭Nginx</h1><p>cmd窗口下，切换到Nginx安装目录，输入以下命令，关闭Nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 快速停止nginx</span><br><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line">-- 完整有序地停止nginx</span><br><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>负载均衡</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper分布式锁应用——秒杀活动</title>
    <url>/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h1><p>淘宝双十一我们都知道，数以亿计的买家在同一时间去争抢有限数量的商品，也就是所谓的商品秒杀活动。面对如此高的并发，如果我们不采取一些措施，将会引发一系列问题，比如：商品超卖、单机锁的失效等。</p>
<h2 id="商品超卖"><a href="#商品超卖" class="headerlink" title="商品超卖"></a>商品超卖</h2><p>假设有100个用户同时去抢一个商品，并且全部下单成功，但是由于并发问题没有得到有效处理，导致实际库存只扣减了99个，也就是发生了1个商品的超卖。</p>
<h2 id="单机锁的失效"><a href="#单机锁的失效" class="headerlink" title="单机锁的失效"></a>单机锁的失效</h2><p>如果我们的服务是单实例的话，可以通过加单机锁来实现对并发问题的处理。这里的单机锁指的是JVM进程级别的锁，比如关键字<code>synchronized</code>、juc并发包下的工具类等等。但如果是分布式系统的话，服务通常是以多实例的姿态出现的，这时候单机锁将会失效。</p>
<span id="more"></span>
<h1 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h1><h2 id="单机环境搭建"><a href="#单机环境搭建" class="headerlink" title="单机环境搭建"></a>单机环境搭建</h2><p>这里我们就简单一点，直接用IDE启动一个SpringBoot项目，提供一个外部调用的REST接口代表商品下单即可，具体代码请参见<code>https://github.com/jyinjuly/zookeeper/tree/master/zookeeper-distributed-lock</code>。这里我们重点看一下Controller层接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.selectProduct(<span class="number">1L</span>);</span><br><span class="line">        log.info(<span class="string">&quot;当前库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            product.setNumber(product.getNumber()-<span class="number">1</span>);</span><br><span class="line">            productService.updateProduct(product);</span><br><span class="line">            log.info(<span class="string">&quot;出库成功，剩余库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口逻辑很简单，首先查询商品，如果商品还有库存，则去做扣减库存操作。</p>
<h2 id="复现商品超卖"><a href="#复现商品超卖" class="headerlink" title="复现商品超卖"></a>复现商品超卖</h2><h3 id="jmeter模拟并发请求"><a href="#jmeter模拟并发请求" class="headerlink" title="jmeter模拟并发请求"></a>jmeter模拟并发请求</h3><p>jmeter的安装这里就不做说明了，请各位读者小伙伴自行百度。我们只介绍本次模拟的相关参数，如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E7%BA%BF%E7%A8%8B%E7%BB%841.png" alt="线程组1.png"><br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/HTTP%E8%AF%B7%E6%B1%821.png" alt="HTTP请求1.png"></p>
<h3 id="请求结果分析"><a href="#请求结果分析" class="headerlink" title="请求结果分析"></a>请求结果分析</h3><p>首先，初始库存如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%9D%E5%A7%8B%E5%BA%93%E5%AD%98.png" alt="初始库存.png"><br>并发请求之后的库存如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E8%B6%85%E5%8D%96%E5%90%8E%E5%BA%93%E5%AD%98.png" alt="超卖后库存.png"><br>什么意思？客户下单成功了100个商品，实际库存却只扣减了3个！什么原因导致的呢？分析如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E8%B6%85%E5%8D%96%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90.png" alt="超卖原因分析.png"><br>究其原因是代码没有针对并发场景做处理导致的。</p>
<h2 id="单机锁解决商品超卖"><a href="#单机锁解决商品超卖" class="headerlink" title="单机锁解决商品超卖"></a>单机锁解决商品超卖</h2><p>针对以上单机环境的并发问题，可以通过加JVM锁处理。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/deduct&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 单机版加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (ProductController.class) &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.selectProduct(<span class="number">1L</span>);</span><br><span class="line">        log.info(<span class="string">&quot;当前库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            product.setNumber(product.getNumber()-<span class="number">1</span>);</span><br><span class="line">            productService.updateProduct(product);</span><br><span class="line">            log.info(<span class="string">&quot;出库成功，剩余库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，初始库存如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%9D%E5%A7%8B%E5%BA%93%E5%AD%98.png" alt="初始库存.png"><br>并发请求之后的库存如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%89%A9%E4%BD%99%E5%BA%93%E5%AD%98.png" alt="剩余库存.png"></p>
<h2 id="分布式环境搭建"><a href="#分布式环境搭建" class="headerlink" title="分布式环境搭建"></a>分布式环境搭建</h2><p>这里我们通过IDE并行启动两个服务实例，端口号分别为8080和8081。然后通过（本地）Nginx将请求反向代理到这两个实例，实现简单的分布式系统。</p>
<h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="Nginx反向代理.png"></p>
<h3 id="服务并行启动"><a href="#服务并行启动" class="headerlink" title="服务并行启动"></a>服务并行启动</h3><p>首先配置服务允许并行启动，如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%A1%8C%E5%90%AF%E5%8A%A8.png" alt="服务并行启动.png"><br>然后手动修改端口号，分别启动8080服务实例和8081服务实例。</p>
<h2 id="单机锁失效"><a href="#单机锁失效" class="headerlink" title="单机锁失效"></a>单机锁失效</h2><p>有了分布式环境，我们再去测试一下单机锁还能否解决商品超卖的问题，首先修改一下jmeter的HTTP请求，如下：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/HTTP%E8%AF%B7%E6%B1%822.png" alt="HTTP请求2.png"><br>然后模拟并发请求，结果如下，首先，初始库存：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%9D%E5%A7%8B%E5%BA%93%E5%AD%98.png" alt="初始库存.png"><br>并发请求之后的库存：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B6%85%E5%8D%96%E5%90%8E%E5%BA%93%E5%AD%98.png" alt="分布式超卖后库存.png"><br>结果显而易见，单机锁在分布式环境下失效了。</p>
<h1 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h1><p>分布式锁有很多种实现，比如Redis分布式锁、Zookeeper分布式锁等等，这里我们使用的是Zookeeper版本，而且还是Curator框架封装好的工具类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/deduct&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// zookeeper分布式锁</span></span><br><span class="line">    <span class="type">InterProcessMutex</span> <span class="variable">processMutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(curatorFramework, <span class="string">&quot;/product_1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        processMutex.acquire();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.selectProduct(<span class="number">1L</span>);</span><br><span class="line">        log.info(<span class="string">&quot;当前库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            product.setNumber(product.getNumber()-<span class="number">1</span>);</span><br><span class="line">            productService.updateProduct(product);</span><br><span class="line">            log.info(<span class="string">&quot;出库成功，剩余库存：&#123;&#125;&quot;</span>, product.getNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processMutex.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后模拟并发请求，结果如下，首先，初始库存：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%88%9D%E5%A7%8B%E5%BA%93%E5%AD%98.png" alt="初始库存.png"><br>并发请求之后的库存：<br><img src="/2022/10/30/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8/%E5%89%A9%E4%BD%99%E5%BA%93%E5%AD%98.png" alt="剩余库存.png"><br>由此可见，使用分布式锁，分布式环境下的并发问题得以解决。</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper特性——文件系统</title>
    <url>/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Zookeeper有两大特性——文件系统和事件监听机制，本篇介绍文件系统。</p>
<h1 id="文件系统简介"><a href="#文件系统简介" class="headerlink" title="文件系统简介"></a>文件系统简介</h1><p>Zookeeper维护一个类似文件系统的数据结构，如下图：<br><img src="/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Znode.png" alt="Znode.png"></p>
<span id="more"></span>
<p>其中每个目录项都被称为<strong>Znode（节点）</strong>，节点之下还可以增加子节点。每个节点拥有唯一路径path，并且均以根路径&#x2F;开头，节点还可以保存数据。</p>
<h1 id="节点Znode类型"><a href="#节点Znode类型" class="headerlink" title="节点Znode类型"></a>节点Znode类型</h1><h2 id="持久化节点"><a href="#持久化节点" class="headerlink" title="持久化节点"></a>持久化节点</h2><p>PERSISTENT（默认类型节点），客户端与Zookeeper断开连接后，节点依旧存在。只要不手动删除，这类节点将永远存在。</p>
<h2 id="持久化序号节点"><a href="#持久化序号节点" class="headerlink" title="持久化序号节点"></a>持久化序号节点</h2><p>PERSISTENT_SEQUENTIAL，与持久化节点一样，只是Zookeeper会自动给节点名称进行顺序编号。</p>
<blockquote>
<p>create -s</p>
</blockquote>
<h2 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h2><p>EPHEMERAL­，客户端与Zookeeper断开连接后，节点会被删除。</p>
<blockquote>
<p>create -e</p>
</blockquote>
<h2 id="临时序号节点"><a href="#临时序号节点" class="headerlink" title="临时序号节点"></a>临时序号节点</h2><p>EPHEMERAL_SEQUENTIAL，与临时节点一样，只是Zookeeper会自动给节点名称进行顺序编号。</p>
<blockquote>
<p>create -s -e</p>
</blockquote>
<h2 id="容器节点"><a href="#容器节点" class="headerlink" title="容器节点"></a>容器节点</h2><p>Container，3.5.3版本新增。容器节点的表现形式和持久化节点是一样的，区别在于Zookeeper服务端启动后，会有一个单独的线程去扫描所有的容器节点，当发现容器节点的子节点数量为0时，会自动删除该节点，除此之外和持久化节点没有区别。官方注释说是可以用在leader或者锁的场景中。</p>
<blockquote>
<p>create -c</p>
</blockquote>
<h2 id="TTL节点"><a href="#TTL节点" class="headerlink" title="TTL节点"></a>TTL节点</h2><p>带有存活时间的节点，简单来说就是当该节点下面没有子节点的话，超过了TTL指定时间后就会被自动删除，特性跟上面的容器节点很像，只是容器节点没有超时时间而已。默认禁用，只能通过系统配置<code>zookeeper.extendedTypesEnabled=true</code>开启，不稳定。</p>
<blockquote>
<p>create -t</p>
</blockquote>
<h1 id="节点Znode操作"><a href="#节点Znode操作" class="headerlink" title="节点Znode操作"></a>节点Znode操作</h1><h2 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create [‐s] [‐e] [‐c] [‐t ttl] path [data] [acl]</span><br></pre></td></tr></table></figure>
<ul>
<li>新增持久化序号节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create -s /node</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Created &#x2F;node0000000001</p>
</blockquote>
</li>
<li>新增临时节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create -e /node1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Created &#x2F;node1</p>
</blockquote>
</li>
<li>新增持久化节点，并添加数据<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /node2 node-data</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Created &#x2F;node2</p>
</blockquote>
</li>
</ul>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><ul>
<li>删除指定节点（不能包含子节点）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete path</span><br></pre></td></tr></table></figure></li>
<li>递归删除节点及其下级所有节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deleteall path</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查询（子）节点"><a href="#查询（子）节点" class="headerlink" title="查询（子）节点"></a>查询（子）节点</h2><ul>
<li>查询指定节点的子节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ls &#x2F;zookeeper<br>[config, quota]</p>
</blockquote>
</li>
<li>递归查询节点及其下级所有节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -R path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ls -R &#x2F;<br>&#x2F;<br>&#x2F;zookeeper<br>&#x2F;zookeeper&#x2F;config<br>&#x2F;zookeeper&#x2F;quota</p>
</blockquote>
</li>
</ul>
<h2 id="节点数据"><a href="#节点数据" class="headerlink" title="节点数据"></a>节点数据</h2><ul>
<li>设置（修改）节点数据<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> path node-data</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set &#x2F;zookeeper zookeeper</p>
</blockquote>
</li>
<li>获取节点数据<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get [-s] path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>get &#x2F;zookeeper<br>zookeeper<br>-s代表同时获取节点状态</p>
</blockquote>
</li>
</ul>
<h2 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>stat &#x2F;zookeeper<br>cZxid &#x3D; 0x0 —— 创建Znode的事务ID<br>ctime &#x3D; Thu Jan 01 08:00:00 CST 1970 —— Znode的创建时间<br>mZxid &#x3D; 0x34 —— 最后修改Znode的事务ID<br>mtime &#x3D; Mon Jun 20 22:32:50 CST 2022 —— Znode的最后修改时间<br>pZxid &#x3D; 0x0 —— 最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）<br>cversion &#x3D; -2 —— Znode的子节点结果集版本（子节点增加、删除都会影响这个版本）<br>dataVersion &#x3D; 2 —— Znode的数据版本<br>aclVersion &#x3D; 0 —— Znode的ACL版本<br>ephemeralOwner &#x3D; 0x0 —— 临时节点所有者的 session ID（零代表为非临时节点）。<br>dataLength &#x3D; 9 —— Znode数据字段的长度<br>numChildren &#x3D; 2 —— Znode子节点的数量</p>
</blockquote>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper特性——事件监听机制</title>
    <url>/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Zookeeper有两大特性——文件系统和事件监听机制，本篇介绍事件监听机制。</p>
<h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><p>Zookeeper中的事件类型有五种，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EventType</span> &#123;</span><br><span class="line">    None (-<span class="number">1</span>),</span><br><span class="line">    NodeCreated (<span class="number">1</span>),            <span class="comment">// 节点被创建时触发</span></span><br><span class="line">    NodeDeleted (<span class="number">2</span>),            <span class="comment">// 节点被删除时触发</span></span><br><span class="line">    NodeDataChanged (<span class="number">3</span>),        <span class="comment">// 节点的节点数据发生变化时触发</span></span><br><span class="line">    NodeChildrenChanged (<span class="number">4</span>),    <span class="comment">// 节点的子节点列表发生变化时触发</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.5.x之后新加的事件类型</span></span><br><span class="line">    DataWatchRemoved (<span class="number">5</span>),       <span class="comment">// 节点的监听被移除时触发</span></span><br><span class="line">    ChildWatchRemoved (<span class="number">6</span>);      <span class="comment">// 节点的子节点的监听被移除时触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="监听类型"><a href="#监听类型" class="headerlink" title="监听类型"></a>监听类型</h1><p>Zookeeper的监听类型总体分为两类，节点数据监听（NodeDataChanged）和节点目录监听（NodeCreated、NodeDeleted、NodeChildrenChanged）。</p>
<h2 id="节点数据监听"><a href="#节点数据监听" class="headerlink" title="节点数据监听"></a>节点数据监听</h2><p>节点数据监听只能针对单个节点设置。当节点的节点数据发生变化时，Zookeeper服务端会向所有注册了该节点数据监听的客户端发送一个NodeDataChanged事件。</p>
<blockquote>
<p>注意：节点数据并不单指节点存储的数据，还包括节点的元数据（状态信息）。</p>
</blockquote>
<h2 id="节点目录监听"><a href="#节点目录监听" class="headerlink" title="节点目录监听"></a>节点目录监听</h2><p>节点目录监听对应三种事件，所以我们也可以将节点目录监听分为三类：</p>
<ul>
<li>节点创建监听（NodeCreated）<blockquote>
<p>当一个节点被创建时，Zookeeper服务端会向所有注册了该节点创建监听的客户端发送一个NodeCreated事件。这里可能会有疑问，如何向一个不存在的节点注册监听？确实，Zookeeper原生客户端不支持这种操作，但是Zookeeper的Java客户端的一些API是支持的。</p>
</blockquote>
</li>
<li>节点删除监听（NodeDeleted）<blockquote>
<p>当一个节点被删除时，Zookeeper服务端会向所有注册了该节点删除监听的客户端发送一个NodeDeleted事件。</p>
</blockquote>
</li>
<li>子节点列表监听（NodeChildrenChanged）<blockquote>
<p>当一个节点发生子节点数量变化（新增、删除）时，Zookeeper服务端会向所有注册了该子节点列表监听的客户端发送一个NodeChildrenChanged事件。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>注意，节点目录监听不仅可以针对单个节点设置，还可以递归对节点及其所有下级节点进行设置。</p>
</blockquote>
<h1 id="监听操作（原生API）"><a href="#监听操作（原生API）" class="headerlink" title="监听操作（原生API）"></a>监听操作（原生API）</h1><h2 id="增加监听"><a href="#增加监听" class="headerlink" title="增加监听"></a>增加监听</h2><ul>
<li>增加节点数据监听<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get -w path</span><br><span class="line"><span class="built_in">stat</span> -w path</span><br></pre></td></tr></table></figure>
<img src="/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC.png" alt="节点数据监听.png"></li>
<li>增加节点目录监听<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -w path</span><br></pre></td></tr></table></figure>
<img src="/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/%E8%8A%82%E7%82%B9%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC1.png" alt="节点目录监听1.png"></li>
<li>递归增加节点目录监听<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -R -w path</span><br></pre></td></tr></table></figure>
<img src="/2022/10/13/Zookeeper%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/%E8%8A%82%E7%82%B9%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC2.png" alt="节点目录监听2.png"><br>这里执行了5条命令，每条命令都有其意义所在：<ul>
<li>ls -R -w &#x2F;：列出所有节点，并给所有节点增加节点目录监听。也就是说有且仅有这7个节点被注册了节点目录监听。</li>
<li>delete &#x2F;test&#x2F;a：触发了<code>/test/a</code>节点的NodeDeleted事件；触发了<code>/test</code>节点的NodeChildrenChanged事件。</li>
<li>delete &#x2F;test&#x2F;b：触发了<code>/test/b</code>节点的NodeDeleted事件；但是没有触发<code>/test</code>节点的NodeChildrenChanged事件，因为上一步已经触发过了。<strong>说到这里不得不提到Zookeeper监听机制一个很重要的特点，那就是所有的监听都是一次性的，一旦监听的事件被触发，监听将会被自动移除。</strong></li>
<li>create &#x2F;test&#x2F;c：新增一个节点，目的是为了测试新节点是否会被注册事件监听。</li>
<li>create &#x2F;test&#x2F;c&#x2F;1：没有触发<code>/test/c</code>节点的NodeChildrenChanged事件，证明新节点不会被注册事件监听。</li>
</ul>
</li>
</ul>
<h2 id="移除监听"><a href="#移除监听" class="headerlink" title="移除监听"></a>移除监听</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">removewatches path</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>事件监听机制</tag>
        <tag>一次性监听</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper的ACL权限控制</title>
    <url>/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Zookeeper的ACL权限控制，可以控制节点的读写操作，保证数据的安全性，Zookeeper的ACL权限设置分为3部分组成，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。最终组成一条例如“scheme:id:permission”格式的ACL请求信息。</p>
<h1 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h1><p>权限模式用来设置ZooKeeper服务器进行权限验证的方式。</p>
<h2 id="IP模式"><a href="#IP模式" class="headerlink" title="IP模式"></a>IP模式</h2><p>ZooKeeper可以针对一个IP或者一段IP地址授予某种权限。比如我们可以让一个IP地址为“ip:192.168.0.110”的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过“ip:192.168.0.1&#x2F;24”给一段IP地址的机器赋权。</p>
<blockquote>
<p>ip:192.168.175.175:rw</p>
</blockquote>
<span id="more"></span>
<h2 id="口令模式"><a href="#口令模式" class="headerlink" title="口令模式"></a>口令模式</h2><p>也可以理解为用户名密码的方式。在ZooKeeper中这种验证方式是Digest认证，而Digest这种认证方式首先在客户端传送“username:password”这种形式的权限表示符后，ZooKeeper服务端会对密码部分使用SHA-1和BASE64算法进行加密，以保证安全性。</p>
<h2 id="超级管理员模式"><a href="#超级管理员模式" class="headerlink" title="超级管理员模式"></a>超级管理员模式</h2><p>Super可以认为是一种特殊的Digest认证。具有Super权限的客户端可以对ZooKeepers上的任意数据节点进行任意操作。</p>
<h2 id="World模式"><a href="#World模式" class="headerlink" title="World模式"></a>World模式</h2><p>world模式表示授权所有用户，一般搭配anyone使用。</p>
<blockquote>
<p>world:anyone:cwrda</p>
</blockquote>
<h1 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h1><p>授权对象就是说我们要把权限赋予谁，而对应于不同的权限模式来说，授权对象有所不同。如下：</p>
<table>
<thead>
<tr>
<th>IP模式</th>
<th>口令模式</th>
<th>超级管理员模式</th>
<th>World模式</th>
</tr>
</thead>
<tbody><tr>
<td>ip地址&#x2F;ip地址列表（多个ip地址以逗号隔开）&#x2F;ip地址段</td>
<td>用户名</td>
<td>用户名</td>
<td>所有用户</td>
</tr>
</tbody></table>
<h1 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h1><h2 id="创建权限（c-create）"><a href="#创建权限（c-create）" class="headerlink" title="创建权限（c:create）"></a>创建权限（c:create）</h2><p>授予权限的对象可以在数据节点下<strong>创建子节点</strong></p>
<h2 id="删除权限（d-delete）"><a href="#删除权限（d-delete）" class="headerlink" title="删除权限（d:delete）"></a>删除权限（d:delete）</h2><p>授予权限的对象可以删除该节点的<strong>子节点</strong></p>
<h2 id="读取权限（r-read）"><a href="#读取权限（r-read）" class="headerlink" title="读取权限（r:read）"></a>读取权限（r:read）</h2><p>授予权限的对象可以读取该节点的节点数据以及子节点的列表信息</p>
<h2 id="更新权限（w-write）"><a href="#更新权限（w-write）" class="headerlink" title="更新权限（w:write）"></a>更新权限（w:write）</h2><p>授予权限的对象可以更新该节点的节点数据</p>
<h2 id="管理权限（a-admin）"><a href="#管理权限（a-admin）" class="headerlink" title="管理权限（a:admin）"></a>管理权限（a:admin）</h2><p>授予权限的对象可以对该节点体进行ACL权限设置</p>
<h1 id="权限操作（API）"><a href="#权限操作（API）" class="headerlink" title="权限操作（API）"></a>权限操作（API）</h1><h2 id="getAcl"><a href="#getAcl" class="headerlink" title="getAcl"></a>getAcl</h2><p>获取某个节点的acl权限信息</p>
<h2 id="setAcl"><a href="#setAcl" class="headerlink" title="setAcl"></a>setAcl</h2><p>设置某个节点的acl权限信息</p>
<h2 id="addauth"><a href="#addauth" class="headerlink" title="addauth"></a>addauth</h2><p>输入认证授权信息，相当于登录</p>
<h1 id="ACL实操"><a href="#ACL实操" class="headerlink" title="ACL实操"></a>ACL实操</h1><h2 id="IP模式-1"><a href="#IP模式-1" class="headerlink" title="IP模式"></a>IP模式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /test test-data ip:192.168.175.175:rw</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建节点，并授予ip地址为192.168.175.175的客户端该节点的读写权限</p>
</blockquote>
<h2 id="口令模式-1"><a href="#口令模式-1" class="headerlink" title="口令模式"></a>口令模式</h2><p>口令模式首先需要生成口令，有两种方式：</p>
<ul>
<li>通过命令直接生成<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> ‐n &lt;user&gt;:&lt;password&gt; | openssl dgst ‐binary ‐sha1 | openssl <span class="built_in">base64</span></span><br></pre></td></tr></table></figure></li>
<li>通过Java API生成<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGenerateDigest</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    log.info(DigestAuthenticationProvider.generateDigest(<span class="string">&quot;user1:password1&quot;</span>)); <span class="comment">// user1:XDkd2dsEuhc9ImU3q8pa8UOdtpI=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /test2 test2-data digest:user1:XDkd2dsEuhc9ImU3q8pa8UOdtpI=:rw</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建节点，并授予用户user1该节点的读写权限</p>
</blockquote>
<p><img src="/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E5%8F%A3%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="口令模式.png"></p>
<p>还有一种明文的口令模式，和digest用法一样，只需要在授权的时候把digest替换成auth即可。只不过需要在登录状态下才可以使用（并且只能授权当前登录用户）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /test3 test3-data auth:user1:password1</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E6%98%8E%E6%96%87%E5%8F%A3%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="明文口令模式.png"></p>
<h2 id="超级管理员模式-1"><a href="#超级管理员模式-1" class="headerlink" title="超级管理员模式"></a>超级管理员模式</h2><p>这是一种特殊的Digest模式， 在Super模式下超级管理员用户可以对Zookeeper上的任意节点进行任何操作。需要在启动时通过JVM系统参数开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dzookeeper.DigestAuthenticationProvider.superDigest=super:BBO7K8dPkoek/JxIHqXxM75QRpI=</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中super为超级管理员用户名，123456为超级管理员密码</p>
</blockquote>
<p>可以通过修改zkServer.sh来启用超级管理员：<br><img src="/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E8%B6%85%E7%BA%A7%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F.png" alt="超级管理员模式.png"></p>
<blockquote>
<p>可以通过<code>nohup</code>快捷搜索定位</p>
</blockquote>
<h2 id="跳过ACL认证"><a href="#跳过ACL认证" class="headerlink" title="跳过ACL认证"></a>跳过ACL认证</h2><p>可以通过系统参数<code>-Dzookeeper.skipACL=yes</code>进行配置，默认是no。可以配置为yes，则配置过的ACL将不再进行权限检测。<br><img src="/2022/10/13/Zookeeper%E7%9A%84ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/%E8%B7%B3%E8%BF%87%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81.png" alt="跳过权限认证.png"></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>ACL</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper单机版安装</title>
    <url>/2022/10/13/Zookeeper%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h1><h2 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># java version &quot;1.8.0_271&quot;</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h2 id="下载并解压Zookeeper"><a href="#下载并解压Zookeeper" class="headerlink" title="下载并解压Zookeeper"></a>下载并解压Zookeeper</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载安装包</span><br><span class="line">wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper‐3.5.8/apache‐zookeeper‐3.5.8‐bin.tar.gz</span><br><span class="line"># 解压安装包</span><br><span class="line">tar ‐zxvf apache‐zookeeper‐3.5.8‐bin.tar.gz</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="备份配置文件（非必须）"><a href="#备份配置文件（非必须）" class="headerlink" title="备份配置文件（非必须）"></a>备份配置文件（非必须）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入配置文件目录</span></span><br><span class="line"><span class="built_in">cd</span> apache-zookeeper-3.5.8-bin/conf/</span><br><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line"><span class="built_in">cp</span> zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<h2 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入脚本文件目录</span></span><br><span class="line"><span class="built_in">cd</span> apache-zookeeper-3.5.8-bin/bin/</span><br><span class="line"><span class="comment"># 启动Zookeeper</span></span><br><span class="line">./zkServer.sh start ../conf/zoo.cfg</span><br><span class="line"><span class="comment"># 检测是否启动</span></span><br><span class="line">ps -ef | grep zookeeper</span><br></pre></td></tr></table></figure>
<h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><h2 id="终端方式连接"><a href="#终端方式连接" class="headerlink" title="终端方式连接"></a>终端方式连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入脚本文件目录</span></span><br><span class="line"><span class="built_in">cd</span> apache-zookeeper-3.5.8-bin/bin/</span><br><span class="line"><span class="comment"># 连接zookeeper</span></span><br><span class="line">./zkCli.sh -server 192.168.175.175:2181</span><br><span class="line"><span class="comment"># 查看所有节点</span></span><br><span class="line"><span class="built_in">ls</span> -R /</span><br></pre></td></tr></table></figure>
<h2 id="可视化工具（ZooInspector）连接"><a href="#可视化工具（ZooInspector）连接" class="headerlink" title="可视化工具（ZooInspector）连接"></a>可视化工具（ZooInspector）连接</h2><ul>
<li>下载工具：<a href="https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip">https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</a></li>
<li>解压，进入目录ZooInspector\build</li>
<li>创建zkClient.bat脚本文件，内容如下：<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">java -jar D:\ZooInspector\build\zookeeper-dev-ZooInspector.jar</span><br></pre></td></tr></table></figure></li>
<li>右键zkClient.bat文件，创建桌面快捷方式，然后修改一个自己喜欢的图标</li>
<li>双击快捷方式，打开可视化工具——ZooInspector，输入连接信息<br><img src="/2022/10/13/Zookeeper%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85/ZooInspector1.png" alt="ZooInspector1.png"></li>
<li>点击OK，连接成功<br><img src="/2022/10/13/Zookeeper%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85/ZooInspector2.png" alt="ZooInspector2.png"></li>
</ul>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>CentOS7</tag>
        <tag>客户端工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper集群搭建</title>
    <url>/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本篇以<strong>一主双从+一观察者</strong>为例搭建Zookeeper集群，旨在介绍集群中的一些概念以及特性。</p>
<h1 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h1><h2 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h2><p>领导者，也可以叫做主节点。主节点可以处理读写请求，集群中只能有一个主节点。</p>
<h2 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h2><p>跟随者，也可以叫做从节点。从节点只处理读请求，同时作为Leader节点的候选节点。即如果Leader宕机，Follower节点会参与到新的Leader选举中，有可能成为新的Leader节点。</p>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>观察者，只能处理读请求，并且不参与选举。通常是为了缓解整个集群的压力，提升集群的并发能力。</p>
<span id="more"></span>

<h1 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h1><p><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/Zookeeper%E9%9B%86%E7%BE%A4.png" alt="Zookeeper集群.png"></p>
<h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><h2 id="创建节点唯一ID"><a href="#创建节点唯一ID" class="headerlink" title="创建节点唯一ID"></a>创建节点唯一ID</h2><p>在Zookeeper的安装目录下，创建如下data目录结构：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E8%8A%82%E7%82%B9%E5%94%AF%E4%B8%80ID.png" alt="节点唯一ID.png"><br>其中的myid文件（文件名固定，不可随意起名）存储代表各个节点的唯一ID，如下：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E8%8A%82%E7%82%B9%E5%94%AF%E4%B8%80ID2.png" alt="节点唯一ID2.png"></p>
<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>在conf目录下，复制zoo_sample.cfg四份，分别命名：zk1.cfg、zk2.cfg、zk3.cfg、zk4.cfg，并进行如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- zk2、zk3、zk4</span><br><span class="line">dataDir=/usr/local/apache-zookeeper-3.5.8-bin/data/zk1</span><br><span class="line"></span><br><span class="line">-- 2182、2183、2184</span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line">server.1=192.168.175.175:2001:3001</span><br><span class="line">server.2=192.168.175.175:2002:3002</span><br><span class="line">server.3=192.168.175.175:2003:3003</span><br><span class="line">server.4=192.168.175.175:2004:3004:observer</span><br></pre></td></tr></table></figure>
<p>其中server.A&#x3D;B:C:D:E，各自含义如下：</p>
<ul>
<li>A：节点唯一ID</li>
<li>B：节点IP</li>
<li>C：集群通讯端口</li>
<li>D：集群选举端口</li>
<li>E：集群角色，默认是participant，即参与者，也就是参与过半机制的角色。另一个是observer，观察者，不参与过半机制。</li>
</ul>
<blockquote>
<p>过半机制有两个场景，第一是选举，第二是事务请求过半提交。</p>
</blockquote>
<h2 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h2><p>集群的启动没有什么特殊之处，就是依次启动各个节点。<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8.png" alt="集群启动.png"><br>然后查看一下集群状态：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81.png" alt="集群状态.png"><br>可以看到：主节点为zk2，从节点为zk1、zk3，观察者如配置为zk4。</p>
<h1 id="集群动态配置"><a href="#集群动态配置" class="headerlink" title="集群动态配置"></a>集群动态配置</h1><p>Zookeeper 3.5.0 以前，Zookeeper集群角色要发生改变的话，只能通过停掉所有的Zookeeper服务，修改集群配置，重启服务来完成，这样集群服务将有一段不可用的状态，为了应对高可用需求，Zookeeper 3.5.0 提供了支持动态扩容&#x2F;缩容的新特性。但是通过客户端API可以变更服务端集群状态是件很危险的事情，所以在zookeeper 3.5.3 版本要用动态配置，需要开启超级管理员身份验证模式 ACLs。如果是在一个安全的环境也可以通过配置系统参数<code>-Dzookeeper.skipACL=yes</code>来避免配置维护acl权限配置。下面我们就承接上文的集群架构，来看看如何进行集群的动态配置。</p>
<h2 id="权限处理"><a href="#权限处理" class="headerlink" title="权限处理"></a>权限处理</h2><p>可以通过<strong>添加超级管理员</strong>或者<strong>跳过权限认证</strong></p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改所有集群节点的配置文件（zk1.cfg, zk2.cfg, zk3.cfg, zk4.cfg），如下：</p>
<ul>
<li>移除clientPort配置</li>
<li>移除集群server.x配置</li>
<li>添加reconfigEnabled配置，设置为true开启动态配置</li>
<li>添加dynamicConfigFile配置，指定动态配置文件的位置</li>
</ul>
<h2 id="添加动态配置文件"><a href="#添加动态配置文件" class="headerlink" title="添加动态配置文件"></a>添加动态配置文件</h2><p>约定俗成，文件以.dynamic结尾，如下：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE.png" alt="动态配置.png"><br>文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server.1=192.168.175.175:2001:3001:participant;192.168.175.175:2181</span><br><span class="line">server.2=192.168.175.175:2002:3002:participant;192.168.175.175:2182</span><br><span class="line">server.3=192.168.175.175:2003:3003:participant;192.168.175.175:2183</span><br><span class="line">server.4=192.168.175.175:2004:3004:observer;192.168.175.175:2184</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在原来集群配置<code>server.A=B:C:D:E</code>的基础上加了一个F，变成了<code>server.A=B:C:D:E;F</code>，F代表服务ip:端口，<strong>注意E和F以分号隔开</strong></p>
</blockquote>
<h2 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h2><p>依次启动所有节点，连接任意一台服务进行操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动节点</span></span><br><span class="line">./bin/zkServer.sh start conf/zk1.cfg</span><br><span class="line">./bin/zkServer.sh start conf/zk2.cfg</span><br><span class="line">./bin/zkServer.sh start conf/zk3.cfg</span><br><span class="line">./bin/zkServer.sh start conf/zk4.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点状态</span></span><br><span class="line">./bin/zkServer.sh status conf/zk1.cfg</span><br><span class="line">./bin/zkServer.sh status conf/zk2.cfg</span><br><span class="line">./bin/zkServer.sh status conf/zk3.cfg</span><br><span class="line">./bin/zkServer.sh status conf/zk4.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要修改集群状态，需要超级管理员登录（或者跳过授权）</span></span><br><span class="line">addauth digest super:123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除id为3的机器</span></span><br><span class="line">reconfig -remove 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加对应机器</span></span><br><span class="line">reconfig -add server.3=192.168.175.175:2003:3003:participant;192.168.175.175:2183</span><br></pre></td></tr></table></figure>
<p>可以看到该过程集群配置变化如下：<br><img src="/2022/10/13/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E9%9B%86%E7%BE%A4%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE.png" alt="集群动态配置.png"></p>
<blockquote>
<p>如果要变更或者添加新的服务，需要满足以下几点：</p>
</blockquote>
<ul>
<li>新服务必须是动态配置节点（配置文件要符合要求）</li>
<li>要将新服务添加到配置文件zk1.cfg.dynamic（注意并不是zk1.cfg.dynamic.xxx）中</li>
<li>新服务要处于启动状态</li>
<li>连接任意一个集群客户端，执行<code>reconfig -add</code>操作</li>
<li>保证服务列表中participant角色能够形成集群（过半机制）</li>
</ul>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>集群</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
</search>
